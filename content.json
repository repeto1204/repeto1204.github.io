{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"자바스크립트 변수","text":"변수변수는 프로그래밍 시 데이터를 관리하기 위한 개념이다. 1 + 2 만약 위와 같은 연산을 컴퓨터에 입력한다면 컴퓨터는 + 연산자 좌, 우의 피연산자를 메모리에 저장하여 기억한다. 메모리는 16진수의 주솟값(0x00000000 ~ 0xFFFFFFFF)을 가지고 있고 이 주솟값은 메모리 공간의 위치를 나타낸다. 컴퓨터는 피연산자 또는 저장할 값을 메모리에 저장할 때 저장할 대상의 자료형과 크기를 판단하여 적절한 메모리 공간의 위치와 크기를 할당하고 저장한다. 컴퓨터는 피연산자의 저장이 완료되면 연산자를 평가하여 구문을 수행한다. 이때 덧셈의 결과 3이 메모리에 저장된다. 하지만 결과 3에 접근할 방법이 없다. 결과에 접근하기 위해서 메모리에 직접 접근해야 하는데 메모리에 직접 접근하게 되면 시스템에서 사용 중인 값을 변경할 수 있게 되고 이는 치명적인 오류로 이어질 수 있다. 또한, 자바스크립트는 메모리 직접 접근을 허용하고 있지 않아 이는 불가능하다. 이때 결과에 접근하기 위해 필요한 것이 변수이다. 변수 선언위의 연산 결과를 저장하기 위해 다음과 같이 변수를 선언하여 저장한다. var result = 1 + 2; 1+2는 3이라는 결과를 생성하고 결과가 저장된 메모리 공간에 접근할 수 있도록 result라는 이름을 붙이는 것이 변수이다. 이렇게 이름을 붙임으로써 메모리에 접근할 수 있게 되고 메모리에 할당된 결괏값을 가져올 수 있다. 변수를 선언할 때에는 키워드를 사용하여 선언한다. 키워드는 var, let, const가 있는데 이 글에서는 var만 사용하도록 한다. 키워드 뒤에 변수의 이름으로 쓰일 단어를 식별자라고 한다. 변수는 아래와 같이 키워드와 식별자를 사용해서 선언할 수 있다. var myVar; 만약 var 키워드로 변수를 선언하고 아무 값도 할당하지 않았다면 해당 변수에는 undefined 가 자동으로 할당된다. 변수에 값을 할당하는 것을 초기화라고 하며 자바스크립트 엔진은 변수 선언을 아래와 같이 두 단계로 수행한다. 선언 단계 : 변수의 이름을 등록한다. 초기화 단계 : 값을 저장하기 위한 공간을 확보하고 값을 할당한다. 만약 변수를 선언하지 않고 사용하려고 한다면 참조에러(ReferenceError) 가 발생하고, 이는 식별자를 찾을 수 없을 때 발생하는 에러이다. 할당변수에 값을 할당하는 방법은 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값 또는 식을 평가하여 좌변의 변수에 할당한다. // 1)var myVar;myVar = 'Hello';// 2)var myVar = 'World'; 1)의 방법처럼 변수의 선언과 할당을 나누어서 할 수도 있고 2)의 방법처럼 한 번에 할 수도 있다. 2)의 방법을 사용해도 내부적으로 선언과 할당을 나누어져 각각 실행되며 선언과 할당은 실행 시점이 다르다. console.log(myVar);var myVar = 'Hello World!';console.log(myVar); 변수의 선언은 런타임 이전에 실행되고 할당은 코드가 실행되는 런타임에 실행된다. 호이스팅변수의 선언 시점은 런타임 이전에 이루어지기 때문에 선언 이전에 변수 참조가 가능하다. var키워드로 선언된 변수는 undefined로 초기화되기 때문에 선언 이전에 사용한다면 undefined를 출력한다. 자바스크립트 엔진은 런타임 이전에 위치에 상관없이 선언문을 먼저 실행한다. 이렇게 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 호이스팅(Hoisting) 이라고 한다. 호이스팅은 변수 선언 뿐만아니라 var, let, const, function, function*, class 키워드를 사용한 식별자 전부 호이스팅 된다. 하지만, 호이스팅이 된다고 해서 모두 선언 이전에 사용할 수 있는 것은 아니다.","link":"/2021/04/04/javascript-variable/"},{"title":"Remove Nth Node From End of List","text":"연결 리스트의 head가 주어질때 뒤에서 n번째 노드를 제거한 후 head를 리턴 제약사항1. 리스트의 노드의 숫자는 size로 한다.2. 1 &lt;= size &lt;= 303. 0 &lt;= Node.val &lt;= 1004. 1 &lt;= n &lt;= size LeetCode 19. Remove Nth Node From End of List Example 1: Input: head = [1,2,3,4,5], n = 2Output: [1,2,3,5] Example 2: Input: head = [1], n = 1Output: [] Example 3: Input: head = [1,2], n = 1Output: [1] Solution/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @param {number} n * @return {ListNode} */const removeNthFromEnd = (head, n) =&gt; { let prev = head, next = head; // block 1) while(n--) { next = next.next; } // block 2) while(next &amp;&amp; next.next) { prev = prev.next; next = next.next; } // block 3) if(!next) { head = head.next; // block 4) } else { prev.next = prev.next ? prev.next.next : null; } return head;}; Block 1) let prev = head, next = head;while(n--) { next = next.next;} 먼저 제거할 타겟의 이전 노드와 다음 노드를 알아내기 위해 prev, next변수를 선언하고 next를 n번 만큼 움직인다. Block 2) while(next &amp;&amp; next.next) { prev = prev.next; next = next.next;} 그 뒤 next가 끝에 도달할 때 까지 prev와 같이 움직여주면 prev는 타겟의 이전 노드가 된다. 1 - 2 - 3 - 4(target) - 5 인 리스트가 있을 때 먼저 n만큼 next를 움직이면 다음과 같다. 1(prev) - 2 - 3(next) - 4(target) - 5 그리고 next가 끝에 도달할 때 까지 prev를 같이 움직이면 최종적으로 다음과 같다. 1 - 2 - 3(prev) - 4(target) - 5(next) Block 3) if(!next) { head = head.next;} 두 번째 while문은 next의 다음 노드가 없을 때는 실행하지 않기 때문에 위의 블록에 진입했다면 첫 번째 while문에서 이미 next가 null이 된것이다. 이 경우는 head가 지워지는 노드이다. 따라서, head에 head.next를 주입한다. head.next에 아무것도 없다면 자연스럽게 null을 리턴할것이다. Block 4) else { prev.next = prev.next ? prev.next.next : null;} prev는 타겟의 왼쪽 노드로 만약 타겟이 있다면 prev.next에 타겟의 .next를 주입한다. 만약 아무것도 없다면 null을 주입한다. return head; 마지막으로 head를 리턴하면 문제가 해결된다.","link":"/2021/03/29/leet-code-remove-nth-node-from-end-of-list/"},{"title":"Two Sum","text":"정수 배열 nums와 정수 target이 주어질 때 더해서 target이 되는 두 수를 구하는 문제 제약사항 1. 2","link":"/2021/04/05/leet-code-two-sum/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"language","slug":"language","link":"/categories/language/"},{"name":"javascript","slug":"language/javascript","link":"/categories/language/javascript/"}]}