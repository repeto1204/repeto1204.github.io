{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"자바스크립트 제어문","text":"제어문자바스크립트 코드는 일반적으로 위에서 아래로 차례대로 실행되는데 이를 제어할 수 있다. 크게 조건에 따라 코드 블록을 실행하는 조건문과 특정 횟수만큼 반복하는 반복문이 있다. 조건문과 반복문을 사용하면 코드의 흐름을 제어하여 특정 코드를 실행할 수 있다. 하지만 과도하게 사용한다면 위에서 아래로 흐르는 직관적인 흐름을 벗어나게 되고 가독성을 저하해 좋지 못한 코드를 만들 가능성이 있다. 조건문조건문은 조건식에 따라 코드 블록을 실행하는 표현식이다. 조건식은 Boolean으로 평가될 수 있는 표현식으로 조건식이 참일 때만 실행한다. 자바스크립트의 조건문은 if...else문과 switch문이 있다. if…else if문은 지정한 조건이 참일 때 명령문을 실행한다. 조건이 거짓인 경우 다른 명령문을 실행하거나 다음 코드 블록을 실행한다. if (조건식) { 명령문www} else if (조건식) { 명령문} else { 명령문} if문은 항상 if가 먼저 나와야 하며 else if 또는 else가 처음부터 올 수 없다. if문 뒤에 나오는 else if는 이전의 if문 또는 else if문이 거짓인 경우 실행하고 if문 뒤에 여러 번 등장할 수 있다. else문은 이전의 조건문이 전부 거짓인 경우 실행하는 구문으로 마지막에 한 번만 사용할 수 있다. if(true) { // 실행} else if(true) { // if문이 실행되기 때문에 실행되지 않음}if(false) { // 조건이 false이기 때문에 실행되지 않음} else if(true) { // if문이 실행되지 않고 조건이 true이기 때문에 실행}if(false) { // 조건이 false이기 때문에 실행되지 않음} else if(false) { // 조건이 false이기 때문에 실행되지 않음} else { // 위 조건이 모두 false이기 때문에 실행} 조건문은 항상 true, false와 같은 boolean형일 필요는 없다. 만약 조건에 어떠한 식이 들어간다면 그 결과를 형 변환하여 평가한다. const str = '';if(str) { console.log('문자열이 있습니다.');} else { console.log('문자열이 없습니다.')} str에는 빈 문자열 ‘’가 들어있지만, 조건문은 이를 형 변환하여 평가한다. ‘’는 false로 형 변환되고 if문을 건너뛰고 else문을 실행한다. if…else의 블록 내의 실행문이 하나뿐이라면 중괄호를 생략할 수 있다. const num = -8;if(num &gt; 0) console.log('양수');else if(num &lt; 0) console.log('음수');else console.log('0'); switch if…else와 같은 조건문으로 표현식이 일치하는 case문을 실행한다. 표현식과 일치하는 case만 실행하고 싶다면 break를 명시적으로 작성해야 한다. if…else의 else처럼 모든 case와 일치하지 않는 경우는 default문을 사용해서 처리할 수 있다. switch(표현식) { case 표현식1: { // 실행문 break; } case 표현식2: { // 실행문 break; } default: { // 실행문 break; }} break는 switch문이나 후에 등장하는 반복문의 실행을 중지하고 다음 코드에 제어권을 넘긴다. 만약 switch문에 break를 사용하지 않으면 표현식과 일치하는 case문부터 마지막 case 또는 default문까지 모두 실행된다. const num = 8;switch(num) { case 0: { console.log('0'); } case 5: { console.log('5'); } case 8: { console.log('8'); } case 10: { console.log('10'); } case 100: { console.log('100'); } default: { console.log('default') }}// 8// 10// 100// default num은 8과 일치하기 때문에 case 8의 구문을 실행한다. 하지만 그 후 switch문을 빠져나가는 break문이 없기 때문에 아래에 있는 모든 실행문을 실행한다. switch문의 case는 묶어서 사용할 수도 있다. 두 가지 이상의 case에 하나의 실행문만 실행해야 한다면 case를 중첩하여 적용하면 된다. const num = 8;switch(num) { case 0: case 5: { console.log('0 또는 5'); break; } case 8: case 10: { console.log('8 또는 10'); break; } case 100: { console.log('100'); break; } default: { console.log('default') }}// 8 또는 10 반복문반복문은 조건식이 참이면 실행문을 실행한다는 점에서 조건문과 같지만, 거짓이 될 때까지 지속해서 반복한다는 차이가 있다. 같은 작업을 반복해야 하거나 특정 자료구조의 개수와 동일한 양의 자료구조를 생성하는 작업에서 코드를 반복 횟수만큼 쓸 필요 없이 반복문을 사용하면 효과적으로 코드의 양을 줄일 수 있다. 기본적인 반복문은 while, do...while, for문이 있다. for for (초기화식; 조건식; 증감식) { 실행문} for문은 초기화식을 기반으로 조건식이 참인 경우 반복문을 수행한다. 1회 반복 후 증감식을 실행하고 그 후 조건식이 참이면 다시 반복하여 조건식이 거짓일 때까지 반복한다. 초기화식에서는 새로운 변수를 선언할 수도 있고 기존의 변수를 초기화하여 사용할 수도 있다. for (let i = 0; i &lt; 10; i++) { console.log(i);} 위 예제에서는 지역변수 키워드로 i를 선언하였고 i가 10보다 작을 때까지 증가시키면서 console.log(i)를 수행하는 코드이다. i가 9일 때까지 실행되고 i++로 증가하여 10이 됐을 때 i &lt; 10은 거짓이기 때문에 실행문을 실행하지 않고 반복을 종료한다. for문의 초기화식, 조건식, 증감식은 생략도 가능하다. 단, 생략 시 무한루프에 빠질 우려가 있는 반복문이라면 반드시 실행문에 조건을 걸어 break로 빠져나오도록 해야 한다. // 초기화식 생략let i =0;for(; i &lt; 10; i++) { // 실행문}// 조건식 생략for(let i = 0;; i++) { // 실행문 // 조건식이 생략되었기 때문에 조건을 걸어 break를 해주어야 한다. if(i &gt; 100) break;}// 모두 생략// 무한 루프for(;;) { // 실행문 // 무한루프를 탈출할 수 있는 break문을 작성해야 한다.} while, do…while while문은 반복 전에 조건을 먼저 검사하고 반복을 시작한다. 보통 반복의 횟수가 명확하지 않을 때 사용한다. do…while문은 먼저 실행문을 한 번 실행 후 조건을 검사한다. // whilewhile(조건식) { 실행문}// do...whiledo { 실행문} while(조건식) let count = 0;while (count &lt; 10) { console.log(count); count++;}count = 0;do { console.log(count); count++;} while (count &lt; 10) while문과 do…while문은 증감식이 따로 없기 때문에 실행문에서 조건에 대한 증감 처리를 해주어야 한다. while (true) { // 실행문 // break} while, do…while문도 for문과 마찬가지로 무한루프를 만들 수 있는데 무한루프 생성 시 실행문 내부에서 조건과 함께 break문을 써주어야 한다. break, continue, label break: 해당 블록의 반복문 또는 레이블이 지정된 반복문을 종료 continue: 해당 블록 또는 레이블이 지정된 반복문의 반복 회차를 종료하고 다음 회차의 반복을 수행 label: 식별자 앞에 붙는 접두어로 break, continue에서 쓰인다. loop1: // labelfor ( let i = 0; i &lt; 10; i++) { loop2: for (let j = 0; j &lt; 10; j++) { if(i === 3 &amp;&amp; j === 3) break loop1; console.log(i, j); }} break와 label을 조합하면 특정 조건에서 특정 루프를 종료할 수 있다. 중첩이 많은 for문을 실행할 때 모든 루프에 조건을 걸어 break할 필요없이 break 뒤에 종료할 루프의 label을 입력하면 해당 루프가 종료된다. loop1: // labelfor ( let i = 0; i &lt; 10; i++) { loop2: for (let j = 0; j &lt; 10; j++) { if(i === j) continue loop1; console.log(i, j); }} label은 continue와 조합할 수도 있다.","link":"/2021/04/26/language/javascript/javascript-control-flow/"},{"title":"자바스크립트 데이터 타입","text":"데이터 타입자바스크립트의 데이터 타입은 원시 타입(Primitive)과 객체 타입(Object)으로 구분할 수 있다. 원시 타입 Null Undefined Boolean Number Bigint String Symbol 객체 타입 Object nullnull은 어떤 값이 존재하지 않음을 의도적으로 명시하기 위한 표현이다. null은 변수가 어떠한 객체나 값을 가리키고 있지 않음을 표시하기 위해 사용한다. var foo = 10;// foo는 이제 10을 참조하지 않는다.foo = null; 변수에 null을 할당하면 참조를 명시적으로 제거하는 것을 의미한다. 위의 예시에서 10을 저장하고 있는 메모리는 참조되지 않고 자바스크립트 엔진에 의해 제거된다. 또 함수나 API의 결과가 기대한 값이 없거나 유효한 값이 없는 경우 null을 반환하기도 한다. var root = document.getElementById('root');// HTML 문서에 id가 root인 element가 없으면 null을 반환한다.console.log(root); undefinedundefined는 선언 된 변수나 파라미터에 자동으로 할당되는 값이다. 다른 언어의 경우 쓰레깃값이 들어 있는 경우가 있는데 자바스크립트의 경우는 엔진이 undefined로 초기화한다. var foo;// foo에 값이 할당되지 않아 자동으로 undefined가 할당된다.console.log(foo); // undefinedfunction bar(param) { console.log(param);}// 인수에 아무 값도 전달하지 않으면 인수에는 undefined가 할당된다.bar(); // undefined 또한 함수에 명시적인 반환 값이 없는 경우 함수는 undefined를 반환한다. function foo() {};var bar = foo();console.log(bar); // undefined boolean논리적으로 참과 거짓을 나타내는 값, true와 false 두 가지 값을 가질 수 있다. 명시적으로 값을 선언하거나 표현식이 평가된 값을 할당할 수도 있다. var foo = true;console.log(foo); // truevar bar = 3 == 4;console.log(bar); // false number다른 언어의 경우 int, long, float, double 등 다양한 숫자 타입이 있는 경우가 있는데 자바스크립트의 숫자 자료형은 정수형, 실수형을 통틀어 number 타입을 사용한다. number 타입은 숫자 이외에 +Infinity, -Infinity, NaN의 값을 표현할 수 있다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : Not a Number (숫자가 아님) 자바스크립트의 숫자 표현은 IEEE 754 표준의 일부인 배정밀도 64비트 부동소수점 형식을 따른다. 따라서 안전하게 표현할 수 있는 수의 범위는 -(253-1) ~ 253-1 이다. 안전하게 표현한다는 의미는 비교의 정확성을 의미한다. 예를 들어 Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2의 결과는 거짓이 되어야 하지만 참으로 평가된다. 안전한 범위를 벗어났기 때문에 올바른 평가가 이루어지지 않은 것이다. 자바스크립트의 모든 수는 사실 실수이다. 정수로 표현되는 수도 내부적으로 실수로 표현되고 있다. 이 때문에 정수끼리의 연산 결과도 실수가 나올 수 있다. console.log(1 === 1.0); // trueconsole.log(3 / 2); // 1.5 자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 따로 제공하지 않고 이들은 전부 64비트 부동소수점 형식 2진수로 저장된다. const bin = 0b10000; // 2진수const oct = 0o20; // 8진수const hex = 0x10; // 16진수console.log(bin === oct); // trueconsole.log(oct === hex); // true bigint길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자 형으로 새롭게 추가된 타입이다. 정수 리터럴 끝에 n을 붙이거나 BigInt()를 사용하여 만들 수 있다. const bigInt = 123456789123456789123456789n;const newBigInt = BigInt(&quot;123456789123456789123456789&quot;); 수학 연산이나 비교, 논리 연산도 가능하다. 수학 연산의 경우 일반 숫자와 혼합하여 연산하는 경우 BigInt() 또는 Number()를 사용해 형 변환을 해주어야한다. console.log(1n + 3n); // 4nconsole.log(5n - 2n); // 3nconsole.log(10n * 3n); // 30nconsole.log(10n / 3n); // 3n, 정수형 값을 반환한다.console.log(3n + BigInt(3)); // 6n;console.log(8 + Number(2n)); // 10;console.log(10n + 20); // TypeError 위의 예시처럼 형이 다른 두 숫자 타입끼리의 연산은 TypeError를 반환한다. 또 BigInt는 언제나 정수이고 소수점 이하를 버림 한다. BigInt는 아래와 같은 상황에서 Number의 결과와 같은 결과를 반환한다. Boolean을 사용해 객체로 반환될 때 논리연산자와 함께 사용될 때 if문 등 조건으로 사용될 때 console.log(Boolean(2n)) // trueconsole.log(2n &gt; 1n); // trueconsole.log(2n &gt; 1); // trueconsole.log(1 == 1n); // trueconsole.log(1 === 1n); // falseif(0n) { // 실행 불가} string자바스크립트에서 문자열을 선언하는 방법은 다음과 같다. 큰따옴표 (“) 작은따옴표 (‘) 역 따옴표/백틱 (`) var string;string = &quot;STRING&quot;;string = 'STRING';string = `STRING`; 문자열 내부에서 특수문자를 사용하기 위해 다음과 같은 표현을 사용해야한다. 코드 출력 \\‘ 작은따옴표 \\“ 큰따옴표 \\\\ 역슬래시 \\n 개행 \\b 백스페이스 \\r 캐리지 리턴 \\t 탭 \\v 세로 탭 \\uXXXX 유니코드 만약 문자열 내부에서 개행을 하고 싶다면 \\n 코드를 추가해야 한다. 개행을 원하지 않지만 가독성을 위해 문자열 할당 시 개행을 하고 싶다면 끝에 \\를 붙여 남은 문자열이 있음을 알린다. var str;str = '개행이 되는 문자열\\n입니다.';str = '개행을 원하지는 않지만 \\읽는 사람의 편의를 위해 \\엔터를 삽입하고있습니다.'; 만약 개행을 확인하고 싶으면 alert 을 통해 확인해야한다. HTML은 기본적으로 white space 문자열은 하나의 공백으로 변경하여 출력하기 때문에 여러 번의 개행이 작동하지 않거나 console에서는 개행 문자열 그대로 출력될 수도 있다. 문자열의 연결이 필요하다면 + 연산을 통해 연결할 수 있다. const str1 = '첫 번째 문자열';const str2 = '두 번째 문자열';const str3 = '세 번째 문자열';console.log(str1 + ' ' + str2 + ' ' + str3); // 첫 번째 문자열 두 번째 문자열 세 번째 문자열 백틱을 사용하면 개행을 편하게 사용할 수 있고 문자열 내부에서 ${} 으로 감싼 후 자바스크립트 표현식을 입력하면 표현식의 반환 값이 문자열로 형 변환 되어 삽입된다. const template = `글을 쓰다 개행을 하고 싶으면이렇게 개행을 하면 되고 연산 결과를 출력하고 싶으면 ${1 + 3} 이렇게 하면 된다.` symbol심볼은 유일한 식별자를 만들 때 사용한다. 객체 자료형의 키는 중복되면 값이 덮어 쓰이고 이전 값이 사라지는 문제가 발생하는데 이를 방지하기 위해 유일한 키 값인 심볼을 생성해 사용하는 경우도 있다. 심볼 이외의 원시 자료형은 리터럴을 통해 생성할 수 있지만, 심볼은 Symbol 함수를 호출해서 생성한다. // id는 새로운 심볼을 참조한다.const id = Symbol();// 심볼에는 설명을 붙일 수 있고 디버깅 시 이를 확인할 수 있다.const userHandsomeJ = Symbol('HandomeJ Object Key');// 심볼의 설명을 출력한다.console.log(userHandsomeJ.description); 심볼은 유일한 값이기 때문에 중복될 수 없고 설명이 같아도 설명만 같을 뿐 다른 심볼이 된다. const sym1 = Symbol('mySymbol');const sym2 = Symbol('mySymbol');console.log(sym1 == sym2); // falseconsole.log(sym1 === sym2); // false object지금까지 알아본 자료형은 전부 원시형(primitive type)이다. 객체형은 원시형과 다르게 키(key)와 값(value)으로 구분된 다양한 자료를 저장할 수 있는 자료구조이다. 키에는 문자형, 심볼형이 들어갈 수 있고, 값에는 모든 자료형이 허용된다. 객체의 값은 키를 이용해 호출할 수 있고 . 또는 []를 통해 호출할 수 있다. const privateNum = Symbol('privateNum');const obj = { name: 'HandsomeJ', [privateNum]: 13721987}console.log(obj.name); // HandsomeJconsole.log(obj[privateNum]); // 13721987","link":"/2021/04/11/language/javascript/javascript-data-type/"},{"title":"자바스크립트 객체","text":"객체자바스크립트에서는 원시 자료형을 제외한 나머지 자료형은 모두 객체이다. 원시 자료형과 달리 객체는 다양한 데이터를 담을 수 있고 키(key)와 값(value)으로 구성된 프로퍼티를 여러 개 넣을 수 있다. 객체의 값은 자바스크립트에서 사용할 수 있는 모든 값이 허용되며 함수도 가능하다. const Owner = { name: 'HandsomeJ', age: 500, greeting: () =&gt; { console.log('Hello!'); }} 객체의 값을 프로퍼티(property)라고 부르며 프로퍼티가 함수인 경우 메서드(method)라고 부른다. 객체의 생성객체를 생성하는 방법은 아래와 같다. 객체 리터럴 생성자 함수 Object.create 메서드 클래스 객체 리터럴 가장 일반적인 객체 생성 방법으로 중괄호를 사용하고 중괄호 내부에 프로퍼티를 정의하면 된다. const User = { id: 'USER', password: '*********', name: 'AAA', printInfo: function() { console.log(this.id); console.log(this.password); console.log(this.name); }} 생성자 함수 생성자 함수를 사용하여 객체를 생성할 수 있다. 원시 자료형도 생성자 함수로 객체를 생성할 수 있다. 생성자 함수 사용 시 반드시 new 키워드와 같이 호출해야 한다. 만약 생성자 함수에서 객체를 반환한다면 결괏값은 반환한 객체가 되고 객체가 아닌 다른 값을 반환한다면 생성자 함수에서 선언한 프로퍼티를 가진 객체가 반환된다. // 1. 생성자 함수를 정의하여 사용function User() { this.id = 'USER'; this.password = '*********'; this.name ='AAA'; // return {test: 'test'}}const user = new User();console.log(user);/*1. return 비활성화 상태일 때User { id: &quot;USER&quot; name: &quot;AAA&quot; password: &quot;*********&quot;}2. return 활성화 상태일 때User { test: 'test'}*/// 2. 원시 타입을 생성자 함수를 사용하여 생성const myString = new String('string');console.log(myString);/*String {&quot;string&quot;}*/ Object.create 메서드 Object 객체의 메서드로 인자로 부여한 객체를 프로토타입으로 하는 새 객체를 생성한다. 두 번째 인자에 객체의 프로퍼티 정보를 입력하면 해당 프로퍼티를 가진 객체가 생성된다. function ParentObject() { this.x = 3;}const Child = Object.create(new ParentObject(), {x: {value: 12}}); 클래스 ES6부터 사용할 수 있게 된 문법으로 class 키워드로 다른 언어의 클래스와 유사한 객체를 생성할 수 있다. 생성자 함수와 차이점은 클래스의 경우 호이스팅이 발생하지 않는다는 점이다. 클래스 내부에서는 constructor 메서드를 사용할 수 있는데 이는 클래스를 초기화하는 특수한 메서드로 클래스 내부에 한 개만 존재할 수 있다. class UserTemplate { constructor(id, name, age) { this.id = id; this.name = name; this.age = age; } getUserName() { return this.name; }}// extends로 상속이 가능하고 상속 시 super()를 호출하여 부모 객체를 생성해야한다.class Customer extends UserTemplate { constructor(id, name, age, order) { super(id, name, age); this.order = order; }}const myCustomer = new Customer('testId', 'testName', 100, 'beer');myCustomer.getUserName(); // testName 프로퍼티객체의 프로퍼티는 키(key)와 값(value)으로 구성되며 각 프로퍼티는 쉼표로 구분한다. 키와 값에 사용할 수 있는 값은 다음과 같다. 프로퍼티 키 : 모든 문자열 또는 심볼 프로퍼티 값 : 자바스크립트에서 사용 가능한 모든 값 const zoo = { name: 'myZoo', lion: 5, monkey: 2} 프로퍼티 생성과 접근 객체 생성 후 프로퍼티를 생성하거나 접근하기 위해서 객체 뒤에 .이나 []를 사용해야한다. .은 일반적인 키를 선언하거나 해당하는 키로 접근하기 위해 사용하고 []는 접근하려는 키가 문자열로 평가되어야 하거나 계산이 필요할 때 사용한다. const myObject = {};const key = 'secondKey';// 선언 시 문자열을 키로 선언하고 싶다면 대괄호를 사용해야한다.// 또한 결괏값이 문자열로 계산되는 식을 키로 선언할 때에도 대괄호를 사용해야한다.myObject.firstKey = 'first Value';myObject[key] = 'second Value';myObject['thirdKey'] = 'third Value';myObject['four' + 'th' + 'Key'] = 'fourth Value';myObject.'lastKey' = 'last Value'; //error, 문자열 키를 대괄호를 사용하지 않으면 에러가 발생한다.console.log(myObject);/*{ firstKey: &quot;first Value&quot;, secondKey: &quot;second Value&quot;, thirdKey: &quot;third Value&quot;, fourthKey: &quot;fourth Value&quot;}*/myObject['firstKey']; // first ValuemyObject['second' + 'Key']; // second ValuemyObject.thirdKey; // third ValuemyObject[fourthKey] // error, fourthKey라는 키는 존재하지만 따옴표가 없기 때문에 문자열이 아닌 변수로 평가해서 참조 에러가 발생한다. 프로퍼티 삭제 delete 연산자를 사용하여 프로퍼티를 삭제할 수 있다. 단, 객체 자체를 삭제하는 것은 불가능하다. const myObject = { v1: 1, v2: 2, v3: 3}console.log(myObject);/*{ v1: 1, v2: 2, v3: 3}*/delete myObject.v1;console.log(myObject);/*{ v2: 2, v3: 3}*/delete myObject // 아무 일도 일어나지 않는다.","link":"/2021/07/04/language/javascript/javascript-object/"},{"title":"자바스크립트 연산자","text":"연산자프로그래밍 언어에서는 수학 연산과 유사한 연산자 집합을 지원한다. 일반적인 수학 연산자뿐만 아니라 프로그래밍에 특화된 연산을 지원하고 일부 언어에서는 프로그래머가 정의한 연산자 생성을 허용하는 경우도 있다. 자바스크립트에는 할당, 비교, 산술, 증감, 비트, 논리, 문자열, 삼항 등 여러 가지 연산자 집합을 지원한다. 연산자는 피연산자의 개수에 따라 단항, 이항, 삼항으로 나뉘는데 차례대로 피연산자가 한 개, 두 개, 세 개가 필요한 연산자이다. 산술 연산자산술 연산자는 수학적 계산을 수행해서 새로운 숫자를 만들어내는 연산자이다. 연산자는 피연산자를 대상으로 연산자에 맞는 연산을 수행하고 결과를 반환한다. 만약 수행 결과가 숫자가 아니거나 숫자 형으로 변환할 수 없는 경우 NaN을 반환한다. 이항 산술 연산자 덧셈 연산자 + 뺄셈 연산자 - 곱셈 연산자 * 나눗셈 연산자 / 나머지 연산자 % 거듭제곱 연산자 ** 일반적으로 알고 있는 연산자 이외에 %, **는 특별한 기능을 제공한다. % 연산자 나머지 연산자 %는 a % b라는 식이 존재할 때 a를 b로 나눈 나머지를 정수로 반환한다. console.log(10 % 3) // 10을 3으로 나눈 나머지 1 출력console.log(12 % 3) // 12를 3으로 나눈 나머지 0 출력console.log(11 % 12) // 11을 12로 나눈 나머지 11 출력 &ast;&ast; 연산자 거듭제곱 연산자 **는 a ** b라는 식이 존재할 때 a를 b번 곱한 값(ab)을 반환한다. console.log(2 ** 2) // 4console.log(3 ** 3) // 9console.log(7 ** 3) // 343 단항 산술 연산자 덧셈 연산자 +와 뺄셈 연산자 -는 단항 연산자로 사용 가능하다. + 연산자 + 연산자는 단항 연산자로 쓰일 때 피연산자의 형을 숫자형으로 변경할 수 있다. console.log(+false); // 0console.log(+true); // 1console.log(+'10'); // 숫자 타입 10console.log(+'test'); // NaN - 연산자 - 연산자도 + 연산자와 마찬가지로 피연산자의 형변환이 가능하다. 다른점은 - 연산자는 숫자형에 쓰일 경우 피연산자의 부호를 변경한다는 것이다. console.log(-(10)); // -10console.log(-true); // -1console.log(-(-8)); // 8console.log(-'test'); // NaN 문자열 연결 + 연산자는 피연산자 중 하나가 문자열인 경우 숫자형을 문자열로 변경한 후 연결하여 반환한다. 그 외의 경우는 숫자형으로 형변환하여 연산 결과를 반환한다. console.log('9' + 3); // '93'console.log(10 + '7'); // '17'console.log(3 + true); // 4console.log(12 - null); // 12console.log(10 + undefined); // NaN, undefined는 숫자로 변환되지 않는다. 증가, 감소 연산자숫자를 1 증가하거나 1 감소할 때 사용하는 단항 연산자이다. 증가 연산자 ++ 감소 연산자 -- 증가, 감소 연산자는 피연산자의 값을 변경하는 특징이 있다. 즉, 암묵적인 할당이 이루어진다. 증가, 감소 연산자는 연산자의 위치에 따라 의미가 달라지는데 피연산자의 앞에 있으면 전위, 뒤에 있으면 후위라고 한다. 전위의 경우 먼저 피연산자를 증가, 감소 후 다른 연산을 수행하는 것이고 후위의 경우 다른 연산을 먼저 수행하고 증가, 감소 연산을 수행하는 것이다. let count = 0;let temp;count++;console.log(count); // 1count--;console.log(count); // 0temp = ++count;console.log(temp); // 1console.log(count); // 1temp = count--;console.log(temp); // 1console.log(count); // 0 비교 연산자비교 연산자는 좌변과 우변에 있는 피연산자를 비교하여 그 결과를 Boolean 값으로 반환한다. 동등 비교 연산자 == 일치 비교 연산자 === 부등 비교 연산자 != 불일치 비교 연산자 !== 작음 연산자 &lt; 작거나 같음 연산자 &lt;= 큼 연산자 &gt; 크거나 같음 연산자 &gt;= 자바스크립트는 연산 시 암묵적 형 변환을 통해 타입이 자동으로 변환되는 경우가 있는데, 동등 비교, 부등 비교의 경우 형 변환을 통해 타입을 일치시킨 후 값이 같은지 비교한다. console.log(3 == 3) // trueconsole.log(3 == '3') // trueconsole.log(3 != 3) // falseconsole.log(3 != '3') // false 이러한 방식은 편할 때도 있지만 예측하기 어려운 결과를 만들어 낼 때가 많다. 일치 비교, 불일치 비교 연산자를 사용하면 위의 문제를 해결할 수 있다. 일치 비교, 불일치 비교 연산자는 형 변환을 하지 않고 타입까지 비교하여 값과 타입이 모두 같을 때 true를 반환한다. console.log(3 === 3) // trueconsole.log(3 === '3') // falseconsole.log(3 !== 3) // falseconsole.log(3 !== '3') // true 크기 비교 연산자의 경우 값의 자료형이 다르면 형 변환 후 비교가 진행된다. 문자열 비교의 경우 유니코드 순으로 비교한다. console.log(3 &gt; '2') // trueconsole.log(3 &gt; 3) // falseconsole.log('A' &gt; 'a') // falseconsole.log(2 &lt;= 2) // true 조건 연산자유일한 삼항 연산자로 조건의 결과에 따라 두 개의 값 중 하나를 가질 수 있다. 문법은 아래와 같다. 조건 ? 값1 : 값2 조건의 결과가 참이면 값1을 거짓이면 값2를 반환한다. const x = 3;console.log(x === 3 ? 'x는 3입니다.' : 'x는 3이 아닙니다.'); 논리 연산자논리 연산자는 피연산자로 Boolean형뿐만 아니라 모든 타입의 값을 받을 수 있다. 연산 결과 역시 모든 타입이 될 수 있고 피연산자 중 하나를 반환한다. 논리 AND &amp;&amp; 논리 OR || 논리 NOT ! console.log(true &amp;&amp; true); // trueconsole.log(true || true); // trueconsole.log(false &amp;&amp; true); // falseconsole.log(false || true); // trueconsole.log(true &amp;&amp; false); // falseconsole.log(true || false); // trueconsole.log(!true); // falseconsole.log(!false); // trueconsole.log('temp' &amp;&amp; 'dummy'); // dummy 기타 연산자typeof 연산자 typeof는 단항 연산자로 피연산자의 타입을 문자열로 반환한다. console.log(typeof ''); // stringconsole.log(typeof 100); // numberconsole.log(typeof NaN); // numberconsole.log(typeof true); // booleanconsole.log(typeof undeclaredVariable); // undefinedconsole.log(typeof Symbol()); // symbolconsole.log(typeof BigInt(3)); // bigintconsole.log(typeof []); // objectconsole.log(typeof {}); // objectconsole.log(typeof function(){}); // functionconsole.log(typeof null); // object typeof는 8가지 타입을 문자열로 반환한다. string number boolean undefined symbol bigint object function typeof가 반환하는 타입은 실제 데이터 타입과 항상 일치하는 것은 아니다. null의 경우 원시 자료형에 null이 있음에도 object를 반환한다. 이는 자바스크립트 초기 버전의 버그로 하위 호환성 때문에 아직 고쳐지지 않은 문제이다. 따라서 null 타입을 확인할 때에는 typeof가 아닌 일치 비교 연산자 ===를 사용해야 한다. ?. 연산자 옵셔널 체이닝 연산자는 객체에 에러 없이 접근 가능하게 하는 연산자로 앞의 피연산자가 null, undefined 일 때 객체 참조 또는 함수 실행을 멈추고 undefined를 반환한다. const myData = { name: 'J',};const myName = myData.name;console.log(myName); // 'J'const myHouse = myData.house?.address;console.log(myHouse); // undefined 위와 같이 객체 내에 없는 프로퍼티를 참조하려고 하면 undefined를 반환한다. 만약 옵셔널 체이닝 연산자를 사용하지 않는다면 아래와 같은 문법을 사용해야 할 것이다. const myData = { name: 'J',};const myHouse = myData &amp;&amp; myData.house &amp;&amp; myData.house.address;console.log(myHouse); // undefined 문법이 장황해지지 않는다는 이점이 있다. ?? 연산자 null 병합 연산자는 앞의 좌변을 평가하여 null, undefined가 아니면 좌변을 그렇지 않으면 우변을 반환한다. const name = null;const nickName = null;const id = 'myId';console.log(name ?? nickName ?? id); // 'myId' delete 연산자 객체의 프로퍼티를 삭제할 때 사용한다. const myData = { name: 'J', house: 'Korea'};console.log(myData.house); // 'Korea'delete myData.house;console.log(myData.house); // undefined in 연산자 객체에 프로퍼티가 존재하는지 확인할 때 사용한다. const myData = { name: 'J', house: 'Korea'};console.log('house' in myData); // true new 연산자 유저가 정의한 객체 타입의 인스턴스를 생성할 때 사용한다. 내장 객체를 생성할 때도 사용할 수 있다. function MyData(name, house, car) { this.name = name; this.house = house; this.car = car;}const myData = new MyData('J', null, null);console.log(myData.name); // 'J' instanceof 연산자 좌변의 객체가 우변의 생성자 함수의 인스턴스인지 확인할 때 사용한다. function MyData(name, house, car) { this.name = name; this.house = house; this.car = car;}const myData = new MyData('J', null, null);console.log(myData instanceof MyData); // trueconsole.log(myData instanceof String); // falseconsole.log(myData instanceof Object); // true","link":"/2021/04/24/language/javascript/javascript-operator/"},{"title":"자바스크립트 타입 변환","text":"타입 변환자바스크립트의 모든 값에는 타입이 있다. 값의 타입은 함수와 연산자에 전달될 때 대부분 적절한 자료형으로 자동 변환되거나 개발자가 의도적으로 다른 타입으로 변환할 수 있다. 이러한 행위를 통틀어 타입 변환이라고 하며 명시적 타입변환, 타입 캐스팅(type casting) 또는 암묵적 타입 변환, 형 변환(type conversion)으로 불린다. 명시적 타입 변환개발자가 의도를 가지고 어떠한 값을 특정 타입으로 변경하는 것을 의미한다. 문자열 타입으로 변환 문자열 타입이 아닌 값을 문자열 타입으로 명시적 변환하는 방법은 다음과 같다. String 생성자 함수를 new 연산자 없이 사용 Object.prototype.toString 메서드 사용 // String 생성자 함수 사용String(1); // '1'String(Infinity); // 'infinity'String(true); // 'true'// Object.prototype.toString 메서드 사용(1).toString(); // '1'(Infinity).toString(); // 'infinity'(true).toString(); // 'true' 숫자 타입으로 변환 숫자 타입이 아닌 값을 숫자 타입으로 명시적 변환하는 방법은 다음과 같다. Number 생성자 함수를 new 연산자 없이 사용 parseInt, parseFloat 함수 사용(문자열만 변환 가능) // Number 생성자 함수 사용Number('0'); // 0Number('30.4'); // 30.4Number('-432'); // -432Number(true); // 1Number(false); // 0// parseInt, parseFloat 메서드 사용parseInt('0'); // 0parseFloat('30.4') // 30.4 불린 타입으로 변환 불린 타입이 아닌 값을 불린 타입으로 명시적 변환하는 방법은 다음과 같다. Boolean 생성자 함수를 new 연산자 없이 사용 // Boolean 생성자 함수 사용Boolean('x'); // trueBoolean(''); // falseBoolean('false'); // trueBoolean(0); // falseBoolean(10); // trueBoolean(NaN); // falseBoolean(undefined); // falseBoolean(null); // falseBoolean({}); // trueBoolean([]); // true 암묵적 타입 변환자바스크립트 엔진이 개발자의 의도와 상관없이 코드 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환하는 것을 의미한다. 문자열 타입으로 변환 문자 타입으로 암묵적 타입 변환이 발생하는 경우는 다음과 같다. 0 + ''; // '0'-1 + ''; // '-1'null + ''; // 'null'undefined + ''; // 'undefined' 위 예제와 같이 + 연산자의 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 이때 피연산자 중 문자열이 아닌 피연산자는 암묵적 타입 변환이 발생하여 문자열로 변환된다. 숫자 타입으로 변환 숫자 타입으로 암묵적 타입 변환이 발생하는 경우는 다음과 같다. // 산술 연산자를 사용하는 경우3 - '1'; // 27 * '10'; // 70100 / 'zero' // NaN// 단항 연산자를 사용하는 경우+''; // 0-'1'; // -1+'one'; // NaN+true; // 1+false; // 0+null; // 0+undefined // NaN +를 제외한 산술 연산자를 사용하면 피연산자 중 숫자 타입이 아닌 피연산자는 숫자 타입으로 암묵적 타입 변환이 발생한다. 또 +, - 단항 연산자를 사용하게 되면 마찬가지로 암묵적 타입 변환이 발생한다. 위의 예제에는 없지만, 비교 연산 시에도 암묵적 타입 변환이 발생한다. 불린 타입으로 변환 불린 타입으로 암묵적 타입 변환이 발생하는 경우는 다음과 같다. // 조건식에 사용됐을 때if('') {} // falseif('1') {} // trueif(null) {} // falseif({}) {} // true// 논리 부정 연산자가 사용됐을 때if(!false) {} // trueif(!'1') {} // falseif(!undefined) {} // trueif(![]) {} // false 자바스크립트에는 Truthy와 Falsy라는 개념이 있는데 이는 각각 참으로 평가되는 값, 거짓으로 평가되는 값을 나타낸다. 아래의 값들은 Falsy 값이다. false undefined null 0, -0 NaN ‘’ (빈 문자열) Falsy 값을 제외한 모든 값을 Truthy 값이다. 자바스크립트에서 불린으로 평가되어야 하는 경우 Truthy는 true로, Falsy는 false로 암묵적 타입 변환이 일어난다.","link":"/2021/05/17/language/javascript/javascript-type-casting/"},{"title":"자바스크립트 변수","text":"변수변수는 프로그래밍 시 데이터를 관리하기 위한 개념이다. 1 + 2 만약 위와 같은 연산을 컴퓨터에 입력한다면 컴퓨터는 + 연산자 좌, 우의 피연산자를 메모리에 저장하여 기억한다. 메모리는 16진수의 주솟값(0x00000000 ~ 0xFFFFFFFF)을 가지고 있고 이 주솟값은 메모리 공간의 위치를 나타낸다. 컴퓨터는 피연산자 또는 저장할 값을 메모리에 저장할 때 저장할 대상의 자료형과 크기를 판단하여 적절한 메모리 공간의 위치와 크기를 할당하고 저장한다. 컴퓨터는 피연산자의 저장이 완료되면 연산자를 평가하여 구문을 수행한다. 이때 덧셈의 결과 3이 메모리에 저장된다. 하지만 결과 3에 접근할 방법이 없다. 결과에 접근하기 위해서 메모리에 직접 접근해야 하는데 메모리에 직접 접근하게 되면 시스템에서 사용 중인 값을 변경할 수 있게 되고 이는 치명적인 오류로 이어질 수 있다. 또한, 자바스크립트는 메모리 직접 접근을 허용하고 있지 않아 이는 불가능하다. 이때 결과에 접근하기 위해 필요한 것이 변수이다. 변수 선언위의 연산 결과를 저장하기 위해 다음과 같이 변수를 선언하여 저장한다. var result = 1 + 2; 1+2는 3이라는 결과를 생성하고 결과가 저장된 메모리 공간에 접근할 수 있도록 result라는 이름을 붙이는 것이 변수이다. 이렇게 이름을 붙임으로써 메모리에 접근할 수 있게 되고 메모리에 할당된 결괏값을 가져올 수 있다. 변수를 선언할 때에는 키워드를 사용하여 선언한다. 키워드는 var, let, const가 있는데 이 글에서는 var만 사용하도록 한다. 키워드 뒤에 변수의 이름으로 쓰일 단어를 식별자라고 한다. 변수는 아래와 같이 키워드와 식별자를 사용해서 선언할 수 있다. var myVar; 만약 var 키워드로 변수를 선언하고 아무 값도 할당하지 않았다면 해당 변수에는 undefined 가 자동으로 할당된다. 변수에 값을 할당하는 것을 초기화라고 하며 자바스크립트 엔진은 변수 선언을 아래와 같이 두 단계로 수행한다. 선언 단계 : 변수의 이름을 등록한다. 초기화 단계 : 값을 저장하기 위한 공간을 확보하고 값을 할당한다. 만약 변수를 선언하지 않고 사용하려고 한다면 참조에러(ReferenceError) 가 발생하고, 이는 식별자를 찾을 수 없을 때 발생하는 에러이다. 할당변수에 값을 할당하는 방법은 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값 또는 식을 평가하여 좌변의 변수에 할당한다. // 1)var myVar;myVar = 'Hello';// 2)var myVar = 'World'; 1)의 방법처럼 변수의 선언과 할당을 나누어서 할 수도 있고 2)의 방법처럼 한 번에 할 수도 있다. 2)의 방법을 사용해도 내부적으로 선언과 할당을 나누어져 각각 실행되며 선언과 할당은 실행 시점이 다르다. console.log(myVar);var myVar = 'Hello World!';console.log(myVar); 변수의 선언은 런타임 이전에 실행되고 할당은 코드가 실행되는 런타임에 실행된다. 호이스팅변수의 선언 시점은 런타임 이전에 이루어지기 때문에 선언 이전에 변수 참조가 가능하다. var키워드로 선언된 변수는 undefined로 초기화되기 때문에 선언 이전에 사용한다면 undefined를 출력한다. 자바스크립트 엔진은 런타임 이전에 위치에 상관없이 선언문을 먼저 실행한다. 이렇게 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 호이스팅(Hoisting) 이라고 한다. 호이스팅은 변수 선언 뿐만아니라 var, let, const, function, function*, class 키워드를 사용한 식별자 전부 호이스팅 된다. 하지만, 호이스팅이 된다고 해서 모두 선언 이전에 사용할 수 있는 것은 아니다.","link":"/2021/04/04/language/javascript/javascript-variable/"},{"title":"Two Sum","text":"정수 배열 nums와 정수 target이 주어질 때 더해서 target이 되는 두 수를 구하는 문제 제약사항 1. 2","link":"/2021/04/05/algorithm/leetcode/easy/leet-code-two-sum/"},{"title":"Reverse Integer","text":"부호 있는 32bit 정수 x가 주어질 때 숫자를 뒤집어서 반환 반환되는 x가 범위를 벗어나면 0 반환 제약사항 1. -231","link":"/2021/05/17/algorithm/leetcode/easy/leet-code-reverse-integer/"},{"title":"Add Two Numbers","text":"역순으로 숫자가 저장된 링크드 리스트 l1, l2가 주어질 때 두 숫자의 합의 역순을 링크드 리스트로 반환하는 문제 제약사항 1. 링크드 리스트의 노드 수의 범위는 1 ~ 100 2. 0 &lt;= Node.val &lt;= 9 3. 숫자는 0으로 시작하지 않는다 LeetCode 2. Add Two Numbers Example 1: Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8] Example 2: Input: l1 = [0], l2 = [0]Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]Output: [8,9,9,9,0,0,0,1] Solution/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */const addTwoNumbers = (l1, l2) =&gt; { let carry = 0; let head; let current; while(l1 || l2 || carry) { const val1 = l1 ? l1.val : 0; const val2 = l2 ? l2.val : 0; let sum = val1 + val2 + carry; carry = 0; if(sum &gt;= 10) { carry = Math.floor(sum / 10); sum %= 10; } if(!head) { head = new ListNode(sum); current = head; } else { current.next = new ListNode(sum); current = current.next; } if(l1) l1 = l1.next; if(l2) l2 = l2.next; } return head;}; head부터 tail까지 수의 덧셈을 진행하는 문제로 두 수의 결과가 10 이상이 되면 올림을 해주어야 한다. 먼저 올림 수를 저장할 변수 carry를 선언하고 반환할 head와 현재 노드를 저장할 current를 선언한다. let carry = 0;let head;let current; l1, l2, carray 세 값이 모두 존재하지 않을 때까지 반복하는 while 문을 선언한다. while(l1 || l2 || carry) {} 반복문 내부에서 값이 있으면 값을 선택하고 없으면 0을 선택하여 더한 후 10보다 큰 경우 올림수와 더한 값을 변경한다. const val1 = l1 ? l1.val : 0;const val2 = l2 ? l2.val : 0;let sum = val1 + val2 + carry;carry = 0;// 10보다 큰 경우 10의 배수만큼 올림수에 저장하고// 10으로 나눈 나머지를 sum에 저장한다if(sum &gt;= 10) { carry = Math.floor(sum / 10); sum %= 10;} 만약 head에 값이 없다면 링크드 리스트를 만들어 저장 후 current에 head를 저장한다. head에 값이 있다면 다음 노드에 값을 만들어 저장 후 current에 다음 노드를 저장한다. l1, l2에는 반복이 한 번 끝날 때마다 다음 노드를 저장하여 끝까지 순회할 수 있도록 한다. if(!head) { head = new ListNode(sum); current = head;} else { current.next = new ListNode(sum); current = current.next;}if(l1) l1 = l1.next;if(l2) l2 = l2.next; 마지막으로 head를 반환하면 각 수의 합을 역순으로 저장한 링크드 리스트가 반환된다.","link":"/2021/04/18/algorithm/leetcode/medium/leet-code-add-two-numbers/"},{"title":"Remove Nth Node From End of List","text":"연결 리스트의 head가 주어질때 뒤에서 n번째 노드를 제거한 후 head를 리턴 제약사항1. 리스트의 노드의 숫자는 size로 한다.2. 1 &lt;= size &lt;= 303. 0 &lt;= Node.val &lt;= 1004. 1 &lt;= n &lt;= size LeetCode 19. Remove Nth Node From End of List Example 1: Input: head = [1,2,3,4,5], n = 2Output: [1,2,3,5] Example 2: Input: head = [1], n = 1Output: [] Example 3: Input: head = [1,2], n = 1Output: [1] Solution/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @param {number} n * @return {ListNode} */const removeNthFromEnd = (head, n) =&gt; { let prev = head, next = head; // block 1) while(n--) { next = next.next; } // block 2) while(next &amp;&amp; next.next) { prev = prev.next; next = next.next; } // block 3) if(!next) { head = head.next; // block 4) } else { prev.next = prev.next ? prev.next.next : null; } return head;}; Block 1) let prev = head, next = head;while(n--) { next = next.next;} 먼저 제거할 타겟의 이전 노드와 다음 노드를 알아내기 위해 prev, next변수를 선언하고 next를 n번 만큼 움직인다. Block 2) while(next &amp;&amp; next.next) { prev = prev.next; next = next.next;} 그 뒤 next가 끝에 도달할 때 까지 prev와 같이 움직여주면 prev는 타겟의 이전 노드가 된다. 1 - 2 - 3 - 4(target) - 5 인 리스트가 있을 때 먼저 n만큼 next를 움직이면 다음과 같다. 1(prev) - 2 - 3(next) - 4(target) - 5 그리고 next가 끝에 도달할 때 까지 prev를 같이 움직이면 최종적으로 다음과 같다. 1 - 2 - 3(prev) - 4(target) - 5(next) Block 3) if(!next) { head = head.next;} 두 번째 while문은 next의 다음 노드가 없을 때는 실행하지 않기 때문에 위의 블록에 진입했다면 첫 번째 while문에서 이미 next가 null이 된것이다. 이 경우는 head가 지워지는 노드이다. 따라서, head에 head.next를 주입한다. head.next에 아무것도 없다면 자연스럽게 null을 리턴할것이다. Block 4) else { prev.next = prev.next ? prev.next.next : null;} prev는 타겟의 왼쪽 노드로 만약 타겟이 있다면 prev.next에 타겟의 .next를 주입한다. 만약 아무것도 없다면 null을 주입한다. return head; 마지막으로 head를 리턴하면 문제가 해결된다.","link":"/2021/03/29/algorithm/leetcode/medium/leet-code-remove-nth-node-from-end-of-list/"},{"title":"Valid Parentheses","text":"'(', ')', '{'. '}'. '['. ']'로 이루어진 문자열 s가 주어질 때 문자열 s가 유효한지 판단하는 문제 다음의 경우를 유효하다고 판단한다. 1. 열린 괄호는 같은 유형의 괄호로 닫아야 한다. 2. 열린 괄호는 올바른 순서로 닫아야 한다. 제약사항 1. 1","link":"/2021/05/01/algorithm/leetcode/easy/leet-code-valid-parentheses/"},{"title":"Palindrome Number","text":"정수형 변수 x가 주어질 때 x가 회문인지 판별하는 문제 제약사항 1. -231","link":"/2021/07/08/algorithm/leetcode/easy/leet-code-palindrome-number/"},{"title":"Roman to Integer","text":"7개의 로마 숫자가 주어질 때 해당하는 숫자를 구하는 문제 Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 제약사항 1. 1","link":"/2021/07/09/algorithm/leetcode/easy/leet-code-roman-to-integer/"},{"title":"Longest Common Prefix","text":"문자열로 구성된 배열이 주어질 때 공통으로 사용할 수 있는 가장 긴 접두어를 찾는 문제 접두어가 없는 경우 빈 문자열을 반환 제약사항 1. 1","link":"/2021/07/09/algorithm/leetcode/easy/leet-code-longest-common-prefix/"},{"title":"자바스크립트 원시값과 객체","text":"원시 값과 객체자바스크립트의 8가지 데이터 타입(Number, String, Boolean, Null, Undefined, Symbol, Bigint, Object)은 원시 타입(primitive type)과 객체 타입(object type)으로 구분된다. 이처럼 데이터 타입을 원시 타입과 객체 타입으로 분류하는 이유는 다음과 같다. 원시 타입은 변경 불가능한 값(immutable value)이고 객체 타입은 변경 가능한 값(mutable value)이다. 원시 값을 변수에 저장하면 변수에는 실제 값이 저장되고 객체를 변수에 저장하면 객체 참조 값이 저장된다. 원시 값을 가진 변수를 다른 변수에 할당하면 원본의 값이 복사되어 전달(pass by value)되고 객체를 참조하고 있는 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달(pass by reference)된다. 원시 값변경 불가능한 값 원시 타입의 값은 변경 불가능한 값이다. 한 번 생성 된 원시 값은 읽기 전용 값으로 변경할 수 없고 불변성을 보장한다. 하지만 이는 변수가 변경될 수 없음을 의미하지 않는다. 변수는 메모리 공간을 식별하기 위해 붙인 이름이고 원시 값은 메모리에 저장된 값을 말하는 것이다. let temp = 10; // temp 값: 10, 10의 메모리 주소: 100temp = 20; // temp 값: 20, 20의 메모리 주소: 200 변수에 원시 값을 할당하면 원시 값이 메모리 공간에 저장되고 변수는 원시 값이 할당된 메모리 공간을 참조한다. 변수에 다른 원시 값을 할당하면 참조하던 메모리 공간의 값을 변경하는 것이 아니라 다른 메모리 공간에 원시 값을 할당하고 변수가 가리키는 주소를 변경한다. 변수에 담긴 원시 값을 변경하는 방법은 재할당밖에 없다. 이러한 특성을 불변성이라고 하는데 이는 변수의 상태 변경 추적을 쉽게 만든다. 이러한 특성이 없다면 메모리에 접근하여 원시 값을 자유롭게 변경할 수 있을 것이고 이는 예기치 못한 값 변경이 발생하거나 변수의 상태 추적을 어렵게 만들 것이다. 값에 의한 전달 let temp1 = 100;let temp2 = temp1;console.log(temp1); // 100console.log(temp2); // 100temp1 = 10;console.log(temp1); // 10console.log(temp2); // 100 temp1에 100을 할당하고 temp2에 temp1을 할당하면 temp1이 100으로 평가되므로 temp2에도 100이 할당된다. 그 후 temp1에 10을 할당하고 temp1과 temp2를 확인하면 temp1만 변경되어있다. 원시값이 복사될 때는 할당되는 변수에 원시 값이 복사되어 전달되고 이를 값에 의한 전달이라고 한다. 최초 할당 시 temp1과 temp2는 같은 값을 갖고 다른 메모리 주소를 갖는다. 이후 어느 한 변수의 값을 변경해도 서로의 값에 영향을 주지 않는다. 객체객체는 프로퍼티의 개수가 정해져 있지 않고 동적으로 추가, 삭제가 가능하다. 프로퍼티의 타입과 값에도 제한이 없기 때문에 선언 시 메모리 공간의 크기를 사전에 정의할 수가 없다. 객체는 원시 값보다 상대적으로 많은 메모리를 소비하고 때에 따라 크기가 매우 큰 경우도 있을 수 있다. 이러한 이유로 객체는 원시 값과 다른 방식으로 동작하도록 설계되어있다. 변경 가능한 값 객체는 변경 가능한 값이다. const note = { price: 2000} 객체를 생성하면 객체를 참조하는 메모리 주소가 변수에 저장된다. 원시 값은 값이 할당된 메모리 주소가 저장되는 반면에 객체는 참조 메모리 주소가 저장된다. 이는 객체의 동적 생성, 삭제의 특성 때문인데 객체에 프로퍼티를 추가, 삭제할 때마다 객체를 재생성할 수 없기 때문에 이러한 방식을 사용한다. const note = { price: 2000}note.spring = true;delete note.price; 위 코드처럼 객체에 프로퍼티를 추가, 삭제 할 수 있다. note 변수에는 객체를 참조하는 주소 값이 할당되어있기 때문에 객체를 변경하더라도 해당 주소는 변경되지 않기 때문에 const 선언을 해도 객체의 변경이 가능하다. 참조에 의한 전달 객체를 저장하는 변수는 객체의 메모리 주소를 저장한다. 이러한 특성은 객체 복사 시 참조 복사가 가능하게 한다. 이는 여러 개의 변수가 하나의 객체를 공유할 수 있다는 것이고, 이로 인해 예기치 못한 상황이 발생할 수도 있다. const schoolA = { teacher: 30, student: 400}const schoolB = schoolA;console.log(schoolA === schoolB) // trueschoolA.teacher = 10;schoolB.student = 300;console.log(schoolA); // {teacher: 10, student: 300}console.log(schoolB); // {teacher: 10, student: 300} schoolA에 객체를 생성하고 schoolB에 schoolA를 복사했다. 이때 객체는 값이 아닌 참조를 복사하기 때문에 두 변수 모두 최초 할당된 객체의 주솟값이 할당된다. 같음 연산자로 비교해보면 동일한 객체로 판명된다. 또 schoolA에 teacher 값을 변경하고, schoolB에 student 값을 변경한 후 두 변수를 확인해보면 모두 변경된 값이 반영되어있다. 객체 복사 시 참조 복사가 되기 때문에 이러한 결과가 발생한다. const schoolA = { teacher: 30, student: 400}const schoolB = { teacher: 30, student: 400}console.log(schoolA === schoolB) // falseschoolA.teacher = 10;schoolB.student = 300;console.log(schoolA); // {teacher: 10, student: 400}console.log(schoolB); // {teacher: 30, student: 300} 객체 리터럴로 선언되는 순간 새로운 객체가 생성된다. 위의 schoolA와 schoolB가 같은 내용이더라도 다른 메모리에 저장되기 때문에 다른 객체로 평가된다. 따라서 변경을 하여도 서로에게 영향을 주지 않는다.","link":"/2021/07/20/language/javascript/javascript-primitive-and-object/"},{"title":"자바스크립트 함수","text":"함수자바스크립트에서 함수는 다른 핵심 개념들과 깊은 연관이 있기 때문에 매우 중요하다. 함수는 입력을 받아 연산하여 결괏값을 반환하거나 어떠한 기능을 수행한다. 함수에는 항상 입출력이 필요한 것은 아니며 만약 함수에서 아무것도 반환하지 않는다면 자동으로 undefined를 반환한다. 프로그램에서 어떠한 반복적인 연산이나 반복적인 일련의 과정을 함수로 정의하여 같은 코드를 줄이고 재사용성을 증가시킨다. 함수의 정의// 함수 리터럴로 함수 정의const myFunction = function add(parameter1, parameter2) { return parameter1 + parameter2;} 함수의 구성은 아래와 같다. 구성 설명 함수 이름(add) - 함수 이름은 식별자 네이밍 규칙을 준수해야 한다.- 함수 이름은 생략할 수 있고 이름이 있으면 기명 함수(named function), 이름이 없으면 익명 함수(anonymous function)라 한다. 매개변수(parameter1, parameter2) - 0개 이상의 매개변수가 존재할 수 있고 소괄호 내부에 위치하며 쉼표로 구분한다.- 각 매개변수는 호출 시 인수가 순서대로 할당된다.- 매개변수는 함수 내부에서 변수와 같이 취급되며 식별자 네이밍 규칙을 준수해야한다. 반환값(parameter1 + parameter2) - return 키워드를 사용하여 함수의 연산 결과 또는 원하는 결괏값을 반환할 수 있다.- 명시적으로 값을 반환하지 않으면 undefined를 반환한다. 함수를 정의하는 방법은 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수가 있으며 네 가지 방법은 모두 함수를 정의하는 방법이지만 약간의 차이가 있다. 함수 선언문 function add(x, y) { return x + y;} 함수 선언문은 함수 리터럴과 형태가 동일하지만 이름을 생략할 수 없다. function(x, y) { return x + y;}// SyntaxError: Function statements require a function name 함수를 실행하면 반환값이 반환되어 변수에 담긴다. 만약 명시적인 반환값이 없다면 undefined가 반환된다. 함수 표현식 함수는 객체 타입의 값이고 변수에 할당할 수도 있다. 함수는 프로퍼티 값이 될 수 있고 배열의 요소도 될 수 있다. 이렇게 값의 성질을 갖는 객체를 일급객체라고 하며 이는 곧 함수를 값처럼 자유롭게 사용할 수 있다는 의미이다. 함수 리터럴로 생성한 함수를 변수에 할당하는 정의 방식을 함수 표현식이라고 한다. const add = function(x, y) { console.log(x + y);}add(1, 2); // 3const foo = function bar() { console.log('bar');}foo(); // 'bar'bar(); // bar is not defined 함수 표현식에 사용하는 함수 리터럴은 함수 이름을 생략할 수 있다. 이를 익명 함수라고 지칭한다. 만약 함수 할당 시 함수에 이름을 붙인 기명 함수를 할당한다고 해도 함수 이름으로 호출할 수는 없다. 함수 이름은 함수 몸체 내부에서만 사용할 수 있기 때문에 함수를 할당한 변수를 통하여 호출해야 한다. function foo() { console.log('foo!');}foo(); // 'foo!' 그렇다면 위 코드는 동작하지 않아야 하는데 실제로 실행해보면 정상 동작한다. foo는 함수 이름이고 함수 이름은 함수 몸체에서만 사용할 수 있기 때문에 호출이 불가능해야 하는데 호출이 가능하다. 그 이유는 자바스크립트 엔진은 생성된 함수 객체를 가리키는 식별자가 없으면 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생각하고 거기에 함수 객체를 할당한다. 이러한 이유로 호출이 가능한 것이다. Function 생성자 함수 const sum = new Function('x', 'y', 'return a + b');console.log(sum(4,5)); // 9 자바스크립트가 기본으로 제공하는 Function 생성자 함수에 매개변수와 함수 몸체를 문자열로 전달하면 함수 객체를 생성하여 반환한다. Function 생성자 함수는 new 키워드를 붙인 것과 붙이지 않은 것 모두 같은 함수 객체를 생성하며 코드 크기 측면에서 new 키워드를 붙이지 않는 것이 더 좋다. Function 생성자 함수는 보안 문제와 eval과 유사한 문제들이 발생할 수 있어 권장되는 방법은 아니다. const closureTest1 = (function(){ let init = 10; return function(x, y) { return x + y + init; }}());console.log(closureTest1(1,2)); // 13const closureTest2 = (function(){ let init = 10; return new Function('x', 'y', 'return x + y + init');}());console.log(closureTest2(1,2)); // init is not defined Function 생성자 함수는 클로저를 생성하지 않는다. 정확히 말해서 전역 범위로 한정된 함수를 생성하기 때문에 클로저 활용이 어렵다. 만약 closureTest2 함수가 동작할 수 있게하고 싶다면 window.init = 10과 같이 전역 변수를 등록해주면 가능하다. 하지만 이는 꽤 바보 같은 행위이다. 화살표 함수 ES6에서 도입된 화살표 함수는 function 키워드를 화살표를 사용함으로써 조금 더 간략하게 함수를 선언할 수 있게 해준다. const sum = (x, y) =&gt; x + y;console.log(sum(1,2)); // 3 화살표 함수는 항상 익명이다. 화살표 함수는 function 키워드를 대체하기 위해 나온 것은 아니고 모양이 간소화된 만큼 내부 동작도 간소화되었다. 화살표 함수는 this, arguments, super를 바인딩하지 않고 new.target 또한 바인딩하지 않는다. 그래서 화살표 함수는 생성자로 사용할 수 없다. 함수 생성 시점과 호이스팅 console.dir(hoistingTest1); // f hoistingTest1(x, y)console.dir(hoistingTest2); // undefinedconsole.log(hoistingTest1(1,2)); // 3console.log(hoistingTest2(1,2)); // TypeError: hoistingTest2 is not a function// 함수 선언문function hoistingTest1(x, y) { return x + y;}// 함수 표현식var hoistingTest2 = function(x, y) { return x + y;} 함수의 경우 자바스크립트 호이스팅이 되어 런타임 이전에 선언이 끌어올려 진다. 함수 선언문의 경우 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되고 선언 후 암묵적으로 같은 이름의 식별자를 생성하고 함수 객체를 할당한다. 이러한 이유로 함수 선언문으로 선언한 함수는 선언문 이전에 참조도 가능하고 호출도 가능하다. 반면에, 함수 표현식으로 작성한 함수는 변수 호이스팅 규칙을 따른다. var 키워드는 호이스팅이 되지만 undefined로 초기화되어 참조 시 undefined가 반환된다. 또 선언 이전에 호출을 시도하면 함수 객체가 할당되어있지 않아 에러가 발생한다. 함수 호출정의된 함수는 함수 이름 또는 선언된 함수가 할당된 변수명 뒤에 인수가 나열된 소괄호를 붙이면 함수가 호출된다. 매개변수와 인수 함수 실행 시 외부 값을 함수 내부로 전달이 필요할 때 매개변수(parameter)를 통해 인수(argument)를 전달한다. function myFunc(x, y) { return x * y;}const result = myFunc(10, 5); 매개변수는 함수를 정의할 때 지정하고 호출할 때 인수를 지정한다. 개수와 타입에 제한은 없으며 값으로 평가될 수 있어야 한다. 예약어나 괄호처럼 값으로 평가될 수 없는 것은 허용되지 않는다. function myFunc(x, y) { return x * y;}const result = myFunc(10);console.log(result); // NaNconst newResult = myFunc(10, 20, 30);console.log(newResult); // 200console.log(x, y); // x is not defined 매개변수와 인수의 개수가 일치하지 않아도 에러가 발생하지 않는다. 인수가 부족하면 자동으로 undefined가 할당되며 그대로 함수 내부의 구문이 실행된다. 다만 그 결괏값이 달라지거나 변수의 프로퍼티를 참조해야 하는 경우라면 에러가 발생할 수도 있다. 인수가 더 많은 경우 초과한 인수는 무시된다. 또 인수는 함수 내부에서만 참조할 수 있다. 함수 외부에서는 참조할 수 없으며 이를 시도하면 에러가 발생한다. 반환문 함수는 return을 통해 특정 값이나 함수 내부 구문의 결괏값을 반환할 수 있다. return을 명시적으로 사용하지 않으면 함수는 항상 undefined를 반환한다. function returnTest1() { return true; // 반환문 이후의 코드는 실행되지 않음 console.log('after return');}function returnTest2() {}console.log(returnTest1()); // trueconsole.log(returnTest2()); // undefined 위 코드를 보면 반환문 이후의 코드는 실행되지 않으며 반환문이 존재하지 않으면 함수는 undefined를 반환한다. 인수 참조 및 상태 변경함수 내부로 전달되는 인수도 변수와 동일하게 취급되기 때문에 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다. const obj = {};const num = 30;function changeValue(obj, num) { obj.test = true; num = 100; console.log(obj); // {test: true} console.log(num); // 100}changeValue(obj, num);console.log(obj); // {test: true}console.log(num); // 30 함수 내부에서 인수를 전달받을 때 원시 타입의 인수는 변경할 수 없기 때문에 내부에서 재할당하여 새로운 원시값으로 교체한다. 그 결과로 함수 내부에서 num 값은 변경한 100인데 함수 실행 후 num을 다시 확인해보면 원래의 값인 30이 반환된다. 원시타입은 값에 의한 전달을 하므로 이러한 결과가 나온다. 반면에 객체 타입은 참조에 의한 전달이기 때문에 함수 내부에서 값을 변경하면 변경 사항이 그대로 유지된다. 함수 내부에서 obj의 test 프로퍼티를 만들고 true라는 값을 할당했다. 함수 실행 후 obj의 값을 확인해보면 변경 사항이 유지된 채로 결과가 반환된다. 하지만 이는 자칫 예기치 못한 오류를 발생시킬 수도 있다. 하나의 객체를 여러 코드 또는 여러 함수에서 공유할 경우 각 함수에서 객체를 변형시킨다면 다른 함수에서 일관된 값이 반환되지 않을 수 있다. 이를 방지하고자 불변의 객체를 만들어 사용하거나 함수 내부에서 객체의 복사본을 새롭게 생성하는 방법을 사용한다. 함수의 여러 형태즉시 실행 함수 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately invoked Function Expression)라고 한다. 즉시 실행 함수는 단 한 번만 호출되며 다시 실행할 수 없다. (function(){ console.log('IIFE START'); return 'IIFE';}()); 즉시 실행 함수는 기본적으로 익명 함수이다. 기명 함수를 사용할 수도 있지만, 이때는 함수 리터럴로 평가되어 함수 몸체에서만 함수 이름을 참조할 수 있어 사실상 의미 없는 식별자가 된다. 재귀 함수 자기 자신을 호출하는 함수를 재귀 함수(recursive function)라고 한다. 반복되는 처리를 위해 반복문을 쓰는 대신 재귀 함수를 사용하면 간단하게 구현할 수 있다. // for문을 사용한 팩토리얼function factorialUseFor(n) { let result = 1; for(let i = n; i &gt;= 1; i--) { result *= i; } return result;}// 재귀 함수를 사용한 팩토리얼function factorialUseRecursive(n) { if(n &lt;= 1) return 1; return n * factorialUseRecursive(n - 1);}console.log(factorialUseFor(10)); // 3628800console.log(factorialUseRecursive(10)); // 3628800 재귀 함수를 사용할 때 주의할 점은 반드시 멈출 수 있는 조건을 만들어야 한다는 것이다. 재귀 함수는 기본적으로 자기 자신을 무한히 호출하기 때문에 탈출 조건이 없거나 무의미한 탈출 조건을 만든다면 함수가 무한히 호출되어 스택 오버플로를 발생시키고 이는 브라우저를 멈추게 할 수도 있다. 중첩 함수 함수 내부에 정의된 함수를 중첩 함수(nested function)라고 한다. 이는 내부 함수(inner function)라고도 불리며 중첩 함수는 외부 함수의 내부에서만 호출할 수 있다. function outer() { let temp = 3; function inner() { temp += 5; console.log(temp); // 8 } inner();} 어떠한 함수에서 필요한 기능을 함수로 만들 때 함수 내부에 선언하여 해당 함수를 모듈화하고 외부에서 접근할 수 없게 한다. 이는 함수 외부를 오염시키지 않는 방법이다. 만약 특정 조건이 생성되었을 때(if, while, for) 함수를 정의하는 코드를 작성하게 되면 혼란이 발생할 수 있기 때문에 내부 함수를 선언하는 것이 바람직하다. 콜백 함수 함수의 매개변수를 통해 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라고 한다. 이때 매개변수를 통해 콜백함수를 전달받는 함수를 고차 함수(Higher-Order Function)라고 한다. 콜백 함수로 전달된 함수는 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다. 만약 고차함수가 여러 번 호출된다면 콜백 함수를 정의한 후 함수 참조를 전달하는 것이 바람직하다. function hof(char, callbackFunc) { callbackFunc(char);}const callBack = (char) =&gt; { console.log(char); };hof('test', function(char) { console.log(char)}); // testhof('test', callBack); // test hof 함수에서 받을 콜백 함수를 선언하고 함수 몸체에서 해당 콜백 함수를 실행했다. hof 호출 시 익명 함수를 정의하여 전달해도, 정의된 함수의 참조를 전달해도 콜백 함수의 내용이 같다면 그 결과도 같다. 순수 함수와 비순수 함수 어떠한 외부 상태를 의존하지 않고 변경하지 않는 함수를 순수 함수(pure function), 외부 상태에 의존하거나 변경하는 함수를 비순수 함수(impure function)라고 한다. let pureCount = 0;let impureCount = 0;// 순수 함수function increasePureFunction(n) { return ++n;}// 비순수 함수function increaseImpureFunction() { return ++impureCount;}pureCount = increasePureFunction(pureCount);console.log(pureCount);pureCount = increasePureFunction(pureCount);console.log(pureCount);impureCount = increaseImpureFunction();console.log(impureCount);impureCount = increaseImpureFunction();console.log(impureCount); 순수 함수 increasePureFunction는 외부 상태에 의존하지 않으며 외부 상태를 변경하지도 않는다. 인수 n에 의존하여 반환값이 결정된다. 반면에 비순수 함수 increaseImpureFunction는 외부의 impureCount에 의해 반환값이 결정되고 외부 상태도 변경한다. 만약 함수 내부에서 외부 상태를 참조하지 않더라도 매개변수를 통해 참조하여 변경한다면 그것은 비순수 함수에 해당한다. 비순수 함수는 외부 상태를 변경하여 상태 변화 추적을 어렵게 만들기 때문에 최대한 억제하고 순수 함수를 사용하는 것이 좋다.","link":"/2021/08/18/language/javascript/javascript-function/"},{"title":"자바스크립트 스코프","text":"스코프스코프는 유효범위라고도 하며 변수의 범위 또는 접근성, 함수의 범위 또는 함수 내부에서 접근할 수 있는 변수 등이 스코프의 개념 중 일부이다. 함수의 매개변수는 함수의 몸체 내부에서만 접근이 가능한 것도 마찬가지로 스코프의 개념 중 일부이다. 자바스크립트에서 모든 식별자는 자신이 선언된 위치에 의해 유효범위가 결정된다. 이를 스코프라고 한다. 스코프의 종류스코프는 전역(global)과 지역(local)으로 구분할 수 있다. 전역 스코프는 코드의 가장 바깥 영역이 유효 범위인 것을 뜻하고 지역 스코프를 해당 지역이 유효 범위인 것을 뜻한다. // global scopeconst x = 'global x';const y = 'global y';// global scopefunction outerFunc() { // outerFunc local scope const z = 'outerFunc local z'; console.log(x); // global x console.log(y); // global y console.log(z); // outFunc local z // outerFunc local scope function innerFunc() { // innerFunc local scope const x = 'innerFunc local x'; console.log(x); // innerFunc local x console.log(y); // global y console.log(z); // outFunc local z // innerFunc local scope } innerFunc();}outerFunc();console.log(x); // global xconsole.log(z); // ReferenceError: z is not defined 전역 스코프 위의 예제에서 가장 바깥의 영역이 전역 영역이다. 해당 영역에 변수를 선언하면 변수는 전역 스코프를 갖는 전역 변수가 된다. 전역 변수는 어디서든 참조할 수 있다. x 와 y는 전역 영역에 선언되어 어디서든 참조가 가능하고 함수 내부에서도 참조 가능하다. 지역 스코프 지역 스코프는 지역 영역에 변수를 선언했을 때 변수가 갖게 되는 스코프이다. 지역은 함수 몸체 내부 또는 블록 내부를 의미하는데 위 예제에서는 함수 몸체 내부이다. 지역 변수는 선언된 지역이나 하위 지역(지역 내부의 지역)에서만 참조할 수 있다. outerFunc 내부에 선언된 변수 z는 지역 변수이고 해당 지역 내부에 innerFunc에서 참조가 가능하다. innerFunc는 outerFunc의 하위 지역이기 때문이다. 스코프 체인 지역 스코프에서는 상위 지역 스코프를 포함하고 나아가 전역 스코프도 포함한다. 이처럼 스코프가 계층적으로 연결된 것을 스코프 체인이라고 하며 모든 스코프의 최상위 스코프는 전역 스코프이다. const x = 'global x';const g = 'global g';function outer() { const y = 'outer y'; const g = 'outer g'; function inner() { const z = 'inner z'; const g = 'inner g'; console.log(x); // global x console.log(y); // outer y console.log(z); // inner z console.log(g); // inner g } inner();}outer(); 자바스크립트 엔진은 변수 참조 시 스코프 체인을 통해 변수를 검색한다. inner function에서 변수 x를 참조할 때 inner function의 지역 스코프에 x가 없기 때문에 그 상위 스코프인 outer function 지역 스코프를 검색하고 outer function 지역 스코프에도 x가 없기 때문에 전역 스코프의 x를 검색하여 출력한다. 변수 g의 경우 모든 스코프에 선언되어 있지만, inner function의 지역 스코프에 g가 있기 때문에 검색을 중단하고 해당 변수를 참조하여 반환한다. 이처럼 변수 참조 시 현재 스코프부터 상위 스코프를 순차적으로 탐색하여 변수를 검색하고 이때 이용하는 것이 스코프 체인이다. 스코프 체인은 하위에서 상위로 진행하며 하위로 진행하는 경우는 존재하지 않는다. 렉시컬 스코프일반적으로 함수의 상위 스코프를 결정하는 패턴은 두 가지로 볼 수 있다. 함수를 호출한 위치에 따라 상위 스코프 결정 (동적 스코프, dynamic scope) 함수를 정의한 위치에 따라 상위 스코프를 결정 (렉시컬 스코프, lexical scope) const x = 'global x';function foo() { const x = 'foo x'; bar(); // global x}function bar() { console.log(x);}foo(); 만약 자바스크립트의 상위 스코프 결정 패턴이 1번이라면 함수 bar에서 x의 참조 값은 foo x일 것이다. 하지만 자바스크립트는 2번 패턴 즉, 렉시컬 스코프 방식이므로 함수 bar에서 x의 참조 값은 global x이다. 이처럼 함수는 함수가 정의될 때의 상위 스코프를 기억하여 함수가 실행될 때마다 기억한 상위 스코프를 참조한다.","link":"/2021/09/03/language/javascript/javascript-scope/"},{"title":"자바스크립트 프로퍼티 어트리뷰트","text":"내부 슬롯과 내부 메서드자바스크립트의 내부 슬롯(internal slot)과 내부 메서드(internal method)는 자바스크립트의 엔진의 알고리즘을 설명하기 위해 ECMAScript에서 사용하는 의사 프로퍼티(pseudo property)와 의사 메서드(pseudo method)이다. 이는 ECMAScript에 이중 대괄호([[…]])로 감싸서 표현되며 엔진에서 실제로 동작하지만 개발자가 접근할 수 있도록 외부에 공개된 것은 아니다. 원칙적으로 접근하거나 호출할 방법이 제공되지 않으나 일부 내부 슬롯, 내부 메서드의 한하여 간접적으로 접근할 수 있는 수단을 제공한다. const o = {};o.[[prototype]] // Uncaught SyntaxError: Unexpected token '['o.__proto__ // Object.prototype 디스크립터 객체자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 자동으로 정의한다. 이를 디스크립터 객체라고 하는데 데이터(data), 접근자(accessor) 두 가지 형식을 취할 수 있다. 프로퍼티 어트리뷰트는 내부 상태 값인 내부 슬롯이기 때문에 직접 접근할 수 없고 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수 있다. 공유 디스크립터 데이터 디스크립터와 접근자 디스크립터는 다음의 두 가지 키를 공유한다. 프로퍼티 어트리뷰트 디스크립터 객체 프로퍼티 설명 [[Configurable]] configurable 프로퍼티 재정의 가능 여부를 나타낸다. [[Enumerable]] enumerable 프로퍼티 열거 가능 여부를 나타낸다. 데이터 디스크립터 프로퍼티 어트리뷰트 디스크립터 객체 프로퍼티 설명 [[Value]] value 프로퍼티 키를 통해 값에 접근하면 반환된 값 [[Writable]] writable 프로퍼티 값의 변경 가능 여부를 나타낸다. const user = { id: 'userId'}console.log(Object.getOwnPropertyDescriptor(user, 'id'));// {value: 'userId', writable: true, enumerable: true, configurable: true} 접근자 디스크립터 프로퍼티 어트리뷰트 디스크립터 객체 프로퍼티 설명 [[Get]] get 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 [[Set]] set 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 const user = { id: 'userId', nickName: 'useNickName', get userId() { return this.id; }, set userId(id) { this.id = id; }}console.log(Object.getOwnPropertyDescriptor(user, 'userId'));// {enumerable: true, configurable: true, get: ƒ, set: ƒ} 프로퍼티 정의프로퍼티 어트리뷰트는 새로운 프로퍼티를 정의할 때 명시적으로 정의하거나, 기존 프로퍼티의 값을 재정의할 수 있다. Object.defineProperty, Object.defineProperties 메서드를 사용하여 정의한다. 만약 생략한다면 다음과 같은 기본값을 가진다. 프로퍼티 어트리뷰트 디스크립터 객체 프로퍼티 기본값 [[Configurable]] configurable false [[Enumerable]] enumerable false [[Value]] value undefined [[Writable]] writable false [[Get]] get undefined [[Set]] set undefined const user = {};// 데이터 디스크립터Object.defineProperty(user, 'id', { value: 'userId', writable: true, enumerable: true, configurable: true})Object.getOwnPropertyDescriptor(user, 'id');// {value: 'userId', writable: false, enumerable: false, configurable: false}Object.defineProperty(user, 'nickName', { value: 'useNickName' })Object.getOwnPropertyDescriptor(user, 'nickName');// {value: 'useNickName', writable: false, enumerable: false, configurable: false}// [[Writable]]의 값이 false라면 [[Value]]값을 변경할 수 없다.user.nickName = 'newNickName'; // 값을 변경하면 무시된다.// [[Enumerable]]의 값이 false라면 열거할 수 없다.Object.keys(user); // ['id']// [[Configurable]]의 값이 false라면 삭제하거나 재정의 할 수 없다.delete user.nickName; // 프로퍼티를 삭제하면 무시된다.Object.defineProperty(user, 'nickName', { configurable: true }); // Uncaught TypeError: Cannot redefine property: nickName// 접근자 디스크립터Object.defineProperty(user, 'userId', { get() { return this.id; }, set(id) { this.id = id; }, enumerable: true, configurable: true})Object.getOwnPropertyDescriptor(user, 'userId');// {enumerable: true, configurable: true, get: ƒ, set: ƒ} Object.defineProperties 메서드를 사용하면 한 번에 정의할 수 있다. const user = {};// 데이터 디스크립터Object.defineProperties(user, { id: { value: 'userId', writable: true, enumerable: true, configurable: true }, nickName: { value: 'nickName' }, userId: { get() { return this.id; }, set(id) { this.id = id; }, enumerable: true, configurable: true }})console.log(user);/*{ id: &quot;userId&quot;, userId: 'userId', nickName: &quot;nickName&quot;, get userId: ƒ get(), set userId: ƒ set(id), [[Prototype]]: Object}*/ 객체 변경 방지객체는 변경 가능한 값이기 때문에 재할당 없이 직접 변경할 수 있다. 만약 중요한 값 또는 변경되지 않아야 하는 값이 객체에 저장되어있다면 객체 변경을 방지해야 한다. 자바스크립트에는 세 가지의 객체 변경 방지 메서드를 제공하는데 각각 변경 금지 강도가 다르다. 구분 추가 삭제 읽기 쓰기 재정의 Object.preventExtensions X O O O O Object.seal X X O O X Object.freeze X X O X X Object.preventExtentions 새로운 프로퍼티가 객체에 추가되는 것을 방지한다. 즉, 장래의 확장을 방지한다. 프로퍼티는 동적 추가와 ObjectdefineProperty 메서드로 추가할 수 있는데 이 두 가지가 모두 금지된다. 객체가 확장 가능 객체인지 여부는 Object.isExtensible 메서드로 확인할 수 있다. const obj = { value: 'testValue' };Object.isExtensible(obj); // true// 객체의 확장을 방지한다.Object.preventExtensions(obj); Object.isExtensible(obj); // falseobj.name = 'myName'; // 무시된다.// TypeError: Cannot define property name, object is not extensibleObject.defineProperty(obj, 'name', { value: 'myName'});console.log(obj); // { value: 'testValue' }delete obj.value; // 삭제는 가능console.log(obj); // {} Object.seal 객체를 밀봉하여 새로운 프로퍼티를 추가할 수 없게 하고 현재 존재하는 프로퍼티의 모든 속성을 설정 불가능 상태로 만든다. 하지만 쓰기 가능한 속성만 밀봉 후에도 변경할 수 있게 한다. 객체가 밀봉 상태인지 여부는 Object.isSealed 메서드로 확인할 수 있다. const obj = { value: 'testValue' };Object.isSealed(obj); // false// 객체를 밀봉한다.Object.seal(obj); Object.isSealed(obj); // trueObject.getOwnPropertyDescriptors(obj);// value: { value: 'testValue', writable: true, enumerable: true, configurable: false }obj.name = 'myName'; // 무시된다.delete obj.value; // 무시된다.obj.value = 'newValue'; // 변경은 가능하다.console.log(obj); // { value: 'newValue' }// TypeError: Cannot redefine property: valueObject.defineProperty(obj, 'value', { configurable: true }); Object.freeze 객체를 동결한다. 동결된 객체는 모든 것이 금지되고 읽기만 가능하다. 객체의 동결 여부는 Object.isFrozen 메서드로 확인할 수 있다. const obj = { value: 'testValue' };Object.isFrozen(obj); // false// 객체를 동결한다.Object.freeze(obj); Object.isFrozen(obj); // trueObject.getOwnPropertyDescriptors(obj);// value: {value: 'testValue', writable: false, enumerable: true, configurable: false}obj.name = 'myName'; // 무시된다.delete obj.value; // 무시된다.obj.value = 'newValue'; // 무시된다.// TypeError: Cannot redefine property: valueObject.defineProperty(obj, 'value', { configurable: true }); 불변 객체 객체 변경 방지 메서드는 중첩객체의 변경 방지를 보장하지 않는다. 프로퍼티가 객체라면 Object.freeze 메서드로 동결해도 중첩 객체까지 동결할 수 없다. const user = { id: 'userId', info: { name: 'J', age: '18' }}Object.freeze(user);Object.isFrozen(user); // trueObject.isFrozen(user.info); // falseuser.info.city = 'SEOUL';console.log(user); // {id: 'userId', info: {name: 'J', age: '18', city: 'SEOUL'}} 중첩 객체까지 전부 동결하여 불변 객체를 만들고 싶다면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야한다. const deepFreeze = (object) =&gt; { // 객체이고 동결되지 않는 객체만 동결한다. if (object &amp;&amp; typeof object === 'object' &amp;&amp; !Object.isFrozen(object)) { Object.freeze(object); // 모든 프로퍼티를 순회하여 재귀적으로 동결한다. for(const key of Object.keys(object)) { deepFreeze(object[key]); } } return object;}const obj = { internal: { a: null }};deepFreeze(obj);obj2.internal.a = 'anotherValue'; // 무시된다.obj2.internal.a; // null","link":"/2021/09/27/language/javascript/javascript-property-attribute/"},{"title":"자바스크립트 생성자 함수","text":"생성자 함수로 객체 생성객체 리터럴을 사용한 객체 생성 방식은 자바스크립트에서 일반적이고 간단한 객체 생성 방식이다. 객체는 객체 리터럴을 사용하지 않고 생성자 함수를 사용하여 생성할 수 있다. Object 생성자 함수new 연산자와 Object 생성자 함수를 함께 호출하면 빈 객체를 생성하여 반환한다. // 빈 객체 생성const author = new Object();// 프로퍼티 추가author.name = 'Handsome J';author.greeting = function() { console.log(`Hello! I'm ${this.name}!`);}; 생성자 함수란 new 연산자와 함께 호출하여 객체를 생성하는 함수를 뜻한다. 생성자 함수를 사용하여 생성된 객체를 인스턴스라고 한다. 자바스크립트에는 Object 생성자 함수 이외에 String, Number, Boolean, Function, Array 등의 빌트인 생성자 함수를 제공한다. const stringObject = new String('string object');console.log(typeof stringObject); // objectconsole.log(stringObject); // String { 'string object' }const numberObject = new Number(100);console.log(typeof numberObject); // objectconsole.log(numberObject); // Number { 100 }const booleanObject = new Boolean(true);console.log(typeof booleanObject); // objectconsole.log(booleanObject); // Boolean { true } 객체를 생성하는 방법은 생성자 함수보다 객체 리터럴을 생성하는 것이 더 간편하다. 생성자 함수객체 리터럴 생성 방식의 문제점 객체 리터럴은 직관적이고 간편하지만 여러 개의 객체를 생성해야 하는 경우 매번 같은 코드를 기술해야 한다. const user1 = { userName: 'user1', getUserName() { return this.userName; }}console.log(user1.getUserName()); // user1const user2 = { userName: 'user2', getUserName() { return this.userName; }}console.log(user2.getUserName()); // user2 만약 상당히 많은 수의 동일한 객체를 생성해야 한다면 위와 같은 방식은 문제가 될 수 있다. 생성자 함수 생성 방식의 장점 생성자 함수를 객체를 생성하기 위한 템플릿처럼 사용하여 구조가 동일한 객체를 간편하게 생성할 수 있다. function User(userName) { this.userName = useName; this.getUserName = function () { return this.userName; }}const user1 = new User('user1');const user2 = new User('user2');console.log(user1.getUserName()); // user1console.log(user2.getUserName()); // user2 생성자 함수는 말 그대로 함수이며 new 연산자와 함께 호출하면 생성자 함수로 동작한다. 만약 new 연산자를 사용하지 않으면 일반 함수로 동작한다. 생성자 함수의 객체 생성 과정 생성자 함수는 다음과 같은 과정을 통해 객체를 생성한다. 인스턴스 생성 및 this 바인딩 생성자 함수를 실행하면 암묵적으로 빈 객체가 생성되며 생성된 빈 객체는 this에 바인딩 된다. 인스턴스 초기화 생성자 함수 내부의 코드를 실행하여 this에 바인딩 돼 있는 객체를 초기화한다. 인스턴스 반환 생성자 함수 내부의 모든 처리가 끝나면 객체가 반환된다. 만약 다른 객체를 명시적으로 반환하면 this가 아닌 해당 객체가 반환된다. function User(userName) { // 1 // 2 this.userName = userName; this.getUserName = function () { return this.userName; } // 3 // 반환 객체를 명시하면 명시한 객체가 반환된다. // reutnr {};}const user1 = new User('user1');console.log(user1); // User { userName: 'user1', getUserName: f } 내부 메서드 [[Call]], [[Constructor]] 함수는 객체지만 일반 객체와 다르게 호출이 가능하다. 따라서, 함수는 일반 객체가 가지고 있는 내부 슬롯, 내부 메서드 뿐만 아니라 함수 객체만 가지는 내부 슬롯과 내부 메서드를 가지고 있다. 함수를 일반 함수로서 호출하면 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Constructor]]가 호출된다. 내부 메서드 [[Call]]을 갖는 함수를 callable이라고 하며, 내부 메서드 [[Constructor]]를 갖는 함수를 constructor, 그렇지 않은 함수를 non-constructor라고 한다. 모든 함수 객체는 호출할 수 있기 때문에 항상 [[Call]]을 갖고 있지만 모든 함수 객체가 생성자로서 호출될 수는 없기 때문에 constructor일 수도 non-constructor일 수도 있다. constructor, non-constructor 구분 자바스크립트 엔진은 함수의 정의를 평가하여 constructor와 non-constructor를 구분한다. constructor: 함수 선언문, 함수 표현식, 클래스 non-constructor: ES6 메서드 축약표 표현, 화살표 함수 // 일반 함수 정의: 함수 선언문, 함수 표현식function foo() {};const bar = function() {};// 프로퍼티 x에 할당된 것은 일반 함수const baz = { x: function() {}}new foo(); // foo{}new bar(); // bar{}new baz.x(); // x{}// 화살표 함수const arrow = () =&gt; {}; // TypeError: arrow is not a constructornew arrow();// 메서드 정의const obj = { x() {}}new obj.x(); // TypeError: obj.x is not a constructor new 연산자 일반 함수와 생성자 함수의 형식적 차이는 없다. 호출 시 [[Call]]을 호출하는지 [[Constructor]]를 호출하는지의 차이가 있을 뿐이다. new 연산자를 사용하면 [[Call]]이 아닌 [[Constructor]]를 호출한다. 단, new 연산자와 함께 호출하는 함수는 constructor이어야 한다. function User(userName) { this.userName = userName; this.getUserName = function() { return this.userName; }}const userFunction = User('user1');const userConstructor = new User('user2');// 함수 호출로 전역에 생성된 userNameconsole.log(userName); // user1// 생성자 함수로 반환 된 객체의 프로퍼티console.log(userConstructor.userName); // user2 일반 함수와 생성자 함수의 형식 차이는 존재하지 않지만 구분을 위해 생성자 함수는 일반적으로 첫 문자를 대문자로 기술한다. new.target 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 첫 문자를 대문자로 기술한다. 하지만 실수는 언제나 발생할 수 있고 이를 방지하기 위해 new.target을 사용한다. new.target은 생성자 함수가 호출되면 함수 내부에서 함수 자신을 가리킨다. 만약 new 연산자 없이 일반 함수로 호출되면 new.target은 undefined이다. function User(userName) { // 만약 new 연산자와 함께 호출되지 않았으면 new 연산자를 붙여 재귀 호출한다. if(!new.target) { return new User(userName); } this.userName = userName; this.getUserName = function() { return this.userName; }}const user1 = User('user1');console.log(user1.getUserName()); // user1 대부분의 빌트인 생성자 함수는 new 연산자와 함께 호출되었는지 확인 후 적절한 값을 반환한다. 단, String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출하면 해당 객체를 그렇지 않으면 해당 데이터 타입의 값을 반환한다. const str = String(123);console.log(str, typeof str); /// 123 stringconst num = Number('123');console.log(num, typeof num); // 123 numberconst bool = Boolean('true');console.log(bool, typeof bool); // true boolean","link":"/2021/10/26/language/javascript/javascript-constructor-function/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"language","slug":"language","link":"/categories/language/"},{"name":"javascript","slug":"language/javascript","link":"/categories/language/javascript/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","link":"/categories/algorithm/leetcode/"},{"name":"easy","slug":"algorithm/leetcode/easy","link":"/categories/algorithm/leetcode/easy/"},{"name":"medium","slug":"algorithm/leetcode/medium","link":"/categories/algorithm/leetcode/medium/"}]}