{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"자바스크립트 데이터 타입","text":"데이터 타입자바스크립트의 데이터 타입은 원시 타입(Primitive)과 객체 타입(Object)으로 구분할 수 있다. 원시 타입 Null Undefined Boolean Number Bigint String Symbol 객체 타입 Object nullnull은 어떤 값이 존재하지 않음을 의도적으로 명시하기 위한 표현이다. null은 변수가 어떠한 객체나 값을 가리키고 있지 않음을 표시하기 위해 사용한다. var foo = 10;// foo는 이제 10을 참조하지 않는다.foo = null; 변수에 null을 할당하면 참조를 명시적으로 제거하는 것을 의미한다. 위의 예시에서 10을 저장하고 있는 메모리는 참조되지 않고 자바스크립트 엔진에 의해 제거된다. 또 함수나 API의 결과가 기대한 값이 없거나 유효한 값이 없는 경우 null을 반환하기도 한다. var root = document.getElementById('root');// HTML 문서에 id가 root인 element가 없으면 null을 반환한다.console.log(root); undefinedundefined는 선언 된 변수나 파라미터에 자동으로 할당되는 값이다. 다른 언어의 경우 쓰레깃값이 들어 있는 경우가 있는데 자바스크립트의 경우는 엔진이 undefined로 초기화한다. var foo;// foo에 값이 할당되지 않아 자동으로 undefined가 할당된다.console.log(foo); // undefinedfunction bar(param) { console.log(param);}// 인수에 아무 값도 전달하지 않으면 인수에는 undefined가 할당된다.bar(); // undefined 또한 함수에 명시적인 반환 값이 없는 경우 함수는 undefined를 반환한다. function foo() {};var bar = foo();console.log(bar); // undefined boolean논리적으로 참과 거짓을 나타내는 값, true와 false 두 가지 값을 가질 수 있다. 명시적으로 값을 선언하거나 표현식이 평가된 값을 할당할 수도 있다. var foo = true;console.log(foo); // truevar bar = 3 == 4;console.log(bar); // false number다른 언어의 경우 int, long, float, double 등 다양한 숫자 타입이 있는 경우가 있는데 자바스크립트의 숫자 자료형은 정수형, 실수형을 통틀어 number 타입을 사용한다. number 타입은 숫자 이외에 +Infinity, -Infinity, NaN의 값을 표현할 수 있다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : Not a Number (숫자가 아님) 자바스크립트의 숫자 표현은 IEEE 754 표준의 일부인 배정밀도 64비트 부동소수점 형식을 따른다. 따라서 안전하게 표현할 수 있는 수의 범위는 -(253-1) ~ 253-1 이다. 안전하게 표현한다는 의미는 비교의 정확성을 의미한다. 예를 들어 Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2의 결과는 거짓이 되어야 하지만 참으로 평가된다. 안전한 범위를 벗어났기 때문에 올바른 평가가 이루어지지 않은 것이다. 자바스크립트의 모든 수는 사실 실수이다. 정수로 표현되는 수도 내부적으로 실수로 표현되고 있다. 이 때문에 정수끼리의 연산 결과도 실수가 나올 수 있다. console.log(1 === 1.0); // trueconsole.log(3 / 2); // 1.5 자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 따로 제공하지 않고 이들은 전부 64비트 부동소수점 형식 2진수로 저장된다. const bin = 0b10000; // 2진수const oct = 0o20; // 8진수const hex = 0x10; // 16진수console.log(bin === oct); // trueconsole.log(oct === hex); // true bigint길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자 형으로 새롭게 추가된 타입이다. 정수 리터럴 끝에 n을 붙이거나 BigInt()를 사용하여 만들 수 있다. const bigInt = 123456789123456789123456789n;const newBigInt = BigInt(&quot;123456789123456789123456789&quot;); 수학 연산이나 비교, 논리 연산도 가능하다. 수학 연산의 경우 일반 숫자와 혼합하여 연산하는 경우 BigInt() 또는 Number()를 사용해 형 변환을 해주어야한다. console.log(1n + 3n); // 4nconsole.log(5n - 2n); // 3nconsole.log(10n * 3n); // 30nconsole.log(10n / 3n); // 3n, 정수형 값을 반환한다.console.log(3n + BigInt(3)); // 6n;console.log(8 + Number(2n)); // 10;console.log(10n + 20); // TypeError 위의 예시처럼 형이 다른 두 숫자 타입끼리의 연산은 TypeError를 반환한다. 또 BigInt는 언제나 정수이고 소수점 이하를 버림 한다. BigInt는 아래와 같은 상황에서 Number의 결과와 같은 결과를 반환한다. Boolean을 사용해 객체로 반환될 때 논리연산자와 함께 사용될 때 if문 등 조건으로 사용될 때 console.log(Boolean(2n)) // trueconsole.log(2n &gt; 1n); // trueconsole.log(2n &gt; 1); // trueconsole.log(1 == 1n); // trueconsole.log(1 === 1n); // falseif(0n) { // 실행 불가} string자바스크립트에서 문자열을 선언하는 방법은 다음과 같다. 큰따옴표 (“) 작은따옴표 (‘) 역 따옴표/백틱 (`) var string;string = &quot;STRING&quot;;string = 'STRING';string = `STRING`; 문자열 내부에서 특수문자를 사용하기 위해 다음과 같은 표현을 사용해야한다. 코드 출력 \\‘ 작은따옴표 \\“ 큰따옴표 \\\\ 역슬래시 \\n 개행 \\b 백스페이스 \\r 캐리지 리턴 \\t 탭 \\v 세로 탭 \\uXXXX 유니코드 만약 문자열 내부에서 개행을 하고 싶다면 \\n 코드를 추가해야 한다. 개행을 원하지 않지만 가독성을 위해 문자열 할당 시 개행을 하고 싶다면 끝에 \\를 붙여 남은 문자열이 있음을 알린다. var str;str = '개행이 되는 문자열\\n입니다.';str = '개행을 원하지는 않지만 \\읽는 사람의 편의를 위해 \\엔터를 삽입하고있습니다.'; 만약 개행을 확인하고 싶으면 alert 을 통해 확인해야한다. HTML은 기본적으로 white space 문자열은 하나의 공백으로 변경하여 출력하기 때문에 여러 번의 개행이 작동하지 않거나 console에서는 개행 문자열 그대로 출력될 수도 있다. 문자열의 연결이 필요하다면 + 연산을 통해 연결할 수 있다. const str1 = '첫 번째 문자열';const str2 = '두 번째 문자열';const str3 = '세 번째 문자열';console.log(str1 + ' ' + str2 + ' ' + str3); // 첫 번째 문자열 두 번째 문자열 세 번째 문자열 백틱을 사용하면 개행을 편하게 사용할 수 있고 문자열 내부에서 ${} 으로 감싼 후 자바스크립트 표현식을 입력하면 표현식의 반환 값이 문자열로 형 변환 되어 삽입된다. const template = `글을 쓰다 개행을 하고 싶으면이렇게 개행을 하면 되고 연산 결과를 출력하고 싶으면 ${1 + 3} 이렇게 하면 된다.` symbol심볼은 유일한 식별자를 만들 때 사용한다. 객체 자료형의 키는 중복되면 값이 덮어 쓰이고 이전 값이 사라지는 문제가 발생하는데 이를 방지하기 위해 유일한 키 값인 심볼을 생성해 사용하는 경우도 있다. 심볼 이외의 원시 자료형은 리터럴을 통해 생성할 수 있지만, 심볼은 Symbol 함수를 호출해서 생성한다. // id는 새로운 심볼을 참조한다.const id = Symbol();// 심볼에는 설명을 붙일 수 있고 디버깅 시 이를 확인할 수 있다.const userHandsomeJ = Symbol('HandomeJ Object Key');// 심볼의 설명을 출력한다.console.log(userHandsomeJ.description); 심볼은 유일한 값이기 때문에 중복될 수 없고 설명이 같아도 설명만 같을 뿐 다른 심볼이 된다. const sym1 = Symbol('mySymbol');const sym2 = Symbol('mySymbol');console.log(sym1 == sym2); // falseconsole.log(sym1 === sym2); // false object지금까지 알아본 자료형은 전부 원시형(primitive type)이다. 객체형은 원시형과 다르게 키(key)와 값(value)으로 구분된 다양한 자료를 저장할 수 있는 자료구조이다. 키에는 문자형, 심볼형이 들어갈 수 있고, 값에는 모든 자료형이 허용된다. 객체의 값은 키를 이용해 호출할 수 있고 . 또는 []를 통해 호출할 수 있다. const privateNum = Symbol('privateNum');const obj = { name: 'HandsomeJ', [privateNum]: 13721987}console.log(obj.name); // HandsomeJconsole.log(obj[privateNum]); // 13721987","link":"/2021/04/11/javascript-data-type/"},{"title":"자바스크립트 연산자","text":"연산자프로그래밍 언어에서는 수학 연산과 유사한 연산자 집합을 지원한다. 일반적인 수학 연산자뿐만 아니라 프로그래밍에 특화된 연산을 지원하고 일부 언어에서는 프로그래머가 정의한 연산자 생성을 허용하는 경우도 있다. 자바스크립트에는 할당, 비교, 산술, 증감, 비트, 논리, 문자열, 삼항 등 여러 가지 연산자 집합을 지원한다. 연산자는 피연산자의 개수에 따라 단항, 이항, 삼항으로 나뉘는데 차례대로 피연산자가 한 개, 두 개, 세 개가 필요한 연산자이다. 산술 연산자산술 연산자는 수학적 계산을 수행해서 새로운 숫자를 만들어내는 연산자이다. 연산자는 피연산자를 대상으로 연산자에 맞는 연산을 수행하고 결과를 반환한다. 만약 수행 결과가 숫자가 아니거나 숫자 형으로 변환할 수 없는 경우 NaN을 반환한다. 이항 산술 연산자 덧셈 연산자 + 뺄셈 연산자 - 곱셈 연산자 * 나눗셈 연산자 / 나머지 연산자 % 거듭제곱 연산자 ** 일반적으로 알고 있는 연산자 이외에 %, **는 특별한 기능을 제공한다. % 연산자 나머지 연산자 %는 a % b라는 식이 존재할 때 a를 b로 나눈 나머지를 정수로 반환한다. console.log(10 % 3) // 10을 3으로 나눈 나머지 1 출력console.log(12 % 3) // 12를 3으로 나눈 나머지 0 출력console.log(11 % 12) // 11을 12로 나눈 나머지 11 출력 &ast;&ast; 연산자 거듭제곱 연산자 **는 a ** b라는 식이 존재할 때 a를 b번 곱한 값(ab)을 반환한다. console.log(2 ** 2) // 4console.log(3 ** 3) // 9console.log(7 ** 3) // 343 단항 산술 연산자 덧셈 연산자 +와 뺄셈 연산자 -는 단항 연산자로 사용 가능하다. + 연산자 + 연산자는 단항 연산자로 쓰일 때 피연산자의 형을 숫자형으로 변경할 수 있다. console.log(+false); // 0console.log(+true); // 1console.log(+'10'); // 숫자 타입 10console.log(+'test'); // NaN - 연산자 - 연산자도 + 연산자와 마찬가지로 피연산자의 형변환이 가능하다. 다른점은 - 연산자는 숫자형에 쓰일 경우 피연산자의 부호를 변경한다는 것이다. console.log(-(10)); // -10console.log(-true); // -1console.log(-(-8)); // 8console.log(-'test'); // NaN 문자열 연결 + 연산자는 피연산자 중 하나가 문자열인 경우 숫자형을 문자열로 변경한 후 연결하여 반환한다. 그 외의 경우는 숫자형으로 형변환하여 연산 결과를 반환한다. console.log('9' + 3); // '93'console.log(10 + '7'); // '17'console.log(3 + true); // 4console.log(12 - null); // 12console.log(10 + undefined); // NaN, undefined는 숫자로 변환되지 않는다. 증가, 감소 연산자숫자를 1 증가하거나 1 감소할 때 사용하는 단항 연산자이다. 증가 연산자 ++ 감소 연산자 -- 증가, 감소 연산자는 피연산자의 값을 변경하는 특징이 있다. 즉, 암묵적인 할당이 이루어진다. 증가, 감소 연산자는 연산자의 위치에 따라 의미가 달라지는데 피연산자의 앞에 있으면 전위, 뒤에 있으면 후위라고 한다. 전위의 경우 먼저 피연산자를 증가, 감소 후 다른 연산을 수행하는 것이고 후위의 경우 다른 연산을 먼저 수행하고 증가, 감소 연산을 수행하는 것이다. let count = 0;let temp;count++;console.log(count); // 1count--;console.log(count); // 0temp = ++count;console.log(temp); // 1console.log(count); // 1temp = count--;console.log(temp); // 1console.log(count); // 0 비교 연산자비교 연산자는 좌변과 우변에 있는 피연산자를 비교하여 그 결과를 Boolean 값으로 반환한다. 동등 비교 연산자 == 일치 비교 연산자 === 부등 비교 연산자 != 불일치 비교 연산자 !== 작음 연산자 &lt; 작거나 같음 연산자 &lt;= 큼 연산자 &gt; 크거나 같음 연산자 &gt;= 자바스크립트는 연산 시 암묵적 형 변환을 통해 타입이 자동으로 변환되는 경우가 있는데, 동등 비교, 부등 비교의 경우 형 변환을 통해 타입을 일치시킨 후 값이 같은지 비교한다. console.log(3 == 3) // trueconsole.log(3 == '3') // trueconsole.log(3 != 3) // falseconsole.log(3 != '3') // false 이러한 방식은 편할 때도 있지만 예측하기 어려운 결과를 만들어 낼 때가 많다. 일치 비교, 불일치 비교 연산자를 사용하면 위의 문제를 해결할 수 있다. 일치 비교, 불일치 비교 연산자는 형 변환을 하지 않고 타입까지 비교하여 값과 타입이 모두 같을 때 true를 반환한다. console.log(3 === 3) // trueconsole.log(3 === '3') // falseconsole.log(3 !== 3) // falseconsole.log(3 !== '3') // true 크기 비교 연산자의 경우 값의 자료형이 다르면 형 변환 후 비교가 진행된다. 문자열 비교의 경우 유니코드 순으로 비교한다. console.log(3 &gt; '2') // trueconsole.log(3 &gt; 3) // falseconsole.log('A' &gt; 'a') // falseconsole.log(2 &lt;= 2) // true 조건 연산자유일한 삼항 연산자로 조건의 결과에 따라 두 개의 값 중 하나를 가질 수 있다. 문법은 아래와 같다. 조건 ? 값1 : 값2 조건의 결과가 참이면 값1을 거짓이면 값2를 반환한다. const x = 3;console.log(x === 3 ? 'x는 3입니다.' : 'x는 3이 아닙니다.'); 논리 연산자논리 연산자는 피연산자로 Boolean형뿐만 아니라 모든 타입의 값을 받을 수 있다. 연산 결과 역시 모든 타입이 될 수 있고 피연산자 중 하나를 반환한다. 논리 AND &amp;&amp; 논리 OR || 논리 NOT ! console.log(true &amp;&amp; true); // trueconsole.log(true || true); // trueconsole.log(false &amp;&amp; true); // falseconsole.log(false || true); // trueconsole.log(true &amp;&amp; false); // falseconsole.log(true || false); // trueconsole.log(!true); // falseconsole.log(!false); // trueconsole.log('temp' &amp;&amp; 'dummy'); // dummy 기타 연산자typeof 연산자 typeof는 단항 연산자로 피연산자의 타입을 문자열로 반환한다. console.log(typeof ''); // stringconsole.log(typeof 100); // numberconsole.log(typeof NaN); // numberconsole.log(typeof true); // booleanconsole.log(typeof undeclaredVariable); // undefinedconsole.log(typeof Symbol()); // symbolconsole.log(typeof BigInt(3)); // bigintconsole.log(typeof []); // objectconsole.log(typeof {}); // objectconsole.log(typeof function(){}); // functionconsole.log(typeof null); // object typeof는 8가지 타입을 문자열로 반환한다. string number boolean undefined symbol bigint object function typeof가 반환하는 타입은 실제 데이터 타입과 항상 일치하는 것은 아니다. null의 경우 원시 자료형에 null이 있음에도 object를 반환한다. 이는 자바스크립트 초기 버전의 버그로 하위 호환성 때문에 아직 고쳐지지 않은 문제이다. 따라서 null 타입을 확인할 때에는 typeof가 아닌 일치 비교 연산자 ===를 사용해야 한다. ?. 연산자 옵셔널 체이닝 연산자는 객체에 에러 없이 접근 가능하게 하는 연산자로 앞의 피연산자가 null, undefined 일 때 객체 참조 또는 함수 실행을 멈추고 undefined를 반환한다. const myData = { name: 'J',};const myName = myData.name;console.log(myName); // 'J'const myHouse = myData.house?.address;console.log(myHouse); // undefined 위와 같이 객체 내에 없는 프로퍼티를 참조하려고 하면 undefined를 반환한다. 만약 옵셔널 체이닝 연산자를 사용하지 않는다면 아래와 같은 문법을 사용해야 할 것이다. const myData = { name: 'J',};const myHouse = myData &amp;&amp; myData.house &amp;&amp; myData.house.address;console.log(myHouse); // undefined 문법이 장황해지지 않는다는 이점이 있다. ?? 연산자 null 병합 연산자는 앞의 좌변을 평가하여 null, undefined가 아니면 좌변을 그렇지 않으면 우변을 반환한다. const name = null;const nickName = null;const id = 'myId';console.log(name ?? nickName ?? id); // 'myId' delete 연산자 객체의 프로퍼티를 삭제할 때 사용한다. const myData = { name: 'J', house: 'Korea'};console.log(myData.house); // 'Korea'delete myData.house;console.log(myData.house); // undefined in 연산자 객체에 프로퍼티가 존재하는지 확인할 때 사용한다. const myData = { name: 'J', house: 'Korea'};console.log('house' in myData); // true new 연산자 유저가 정의한 객체 타입의 인스턴스를 생성할 때 사용한다. 내장 객체를 생성할 때도 사용할 수 있다. function MyData(name, house, car) { this.name = name; this.house = house; this.car = car;}const myData = new MyData('J', null, null);console.log(myData.name); // 'J' instanceof 연산자 좌변의 객체가 우변의 생성자 함수의 인스턴스인지 확인할 때 사용한다. function MyData(name, house, car) { this.name = name; this.house = house; this.car = car;}const myData = new MyData('J', null, null);console.log(myData instanceof MyData); // trueconsole.log(myData instanceof String); // falseconsole.log(myData instanceof Object); // true","link":"/2021/04/24/javascript-operator/"},{"title":"자바스크립트 변수","text":"변수변수는 프로그래밍 시 데이터를 관리하기 위한 개념이다. 1 + 2 만약 위와 같은 연산을 컴퓨터에 입력한다면 컴퓨터는 + 연산자 좌, 우의 피연산자를 메모리에 저장하여 기억한다. 메모리는 16진수의 주솟값(0x00000000 ~ 0xFFFFFFFF)을 가지고 있고 이 주솟값은 메모리 공간의 위치를 나타낸다. 컴퓨터는 피연산자 또는 저장할 값을 메모리에 저장할 때 저장할 대상의 자료형과 크기를 판단하여 적절한 메모리 공간의 위치와 크기를 할당하고 저장한다. 컴퓨터는 피연산자의 저장이 완료되면 연산자를 평가하여 구문을 수행한다. 이때 덧셈의 결과 3이 메모리에 저장된다. 하지만 결과 3에 접근할 방법이 없다. 결과에 접근하기 위해서 메모리에 직접 접근해야 하는데 메모리에 직접 접근하게 되면 시스템에서 사용 중인 값을 변경할 수 있게 되고 이는 치명적인 오류로 이어질 수 있다. 또한, 자바스크립트는 메모리 직접 접근을 허용하고 있지 않아 이는 불가능하다. 이때 결과에 접근하기 위해 필요한 것이 변수이다. 변수 선언위의 연산 결과를 저장하기 위해 다음과 같이 변수를 선언하여 저장한다. var result = 1 + 2; 1+2는 3이라는 결과를 생성하고 결과가 저장된 메모리 공간에 접근할 수 있도록 result라는 이름을 붙이는 것이 변수이다. 이렇게 이름을 붙임으로써 메모리에 접근할 수 있게 되고 메모리에 할당된 결괏값을 가져올 수 있다. 변수를 선언할 때에는 키워드를 사용하여 선언한다. 키워드는 var, let, const가 있는데 이 글에서는 var만 사용하도록 한다. 키워드 뒤에 변수의 이름으로 쓰일 단어를 식별자라고 한다. 변수는 아래와 같이 키워드와 식별자를 사용해서 선언할 수 있다. var myVar; 만약 var 키워드로 변수를 선언하고 아무 값도 할당하지 않았다면 해당 변수에는 undefined 가 자동으로 할당된다. 변수에 값을 할당하는 것을 초기화라고 하며 자바스크립트 엔진은 변수 선언을 아래와 같이 두 단계로 수행한다. 선언 단계 : 변수의 이름을 등록한다. 초기화 단계 : 값을 저장하기 위한 공간을 확보하고 값을 할당한다. 만약 변수를 선언하지 않고 사용하려고 한다면 참조에러(ReferenceError) 가 발생하고, 이는 식별자를 찾을 수 없을 때 발생하는 에러이다. 할당변수에 값을 할당하는 방법은 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값 또는 식을 평가하여 좌변의 변수에 할당한다. // 1)var myVar;myVar = 'Hello';// 2)var myVar = 'World'; 1)의 방법처럼 변수의 선언과 할당을 나누어서 할 수도 있고 2)의 방법처럼 한 번에 할 수도 있다. 2)의 방법을 사용해도 내부적으로 선언과 할당을 나누어져 각각 실행되며 선언과 할당은 실행 시점이 다르다. console.log(myVar);var myVar = 'Hello World!';console.log(myVar); 변수의 선언은 런타임 이전에 실행되고 할당은 코드가 실행되는 런타임에 실행된다. 호이스팅변수의 선언 시점은 런타임 이전에 이루어지기 때문에 선언 이전에 변수 참조가 가능하다. var키워드로 선언된 변수는 undefined로 초기화되기 때문에 선언 이전에 사용한다면 undefined를 출력한다. 자바스크립트 엔진은 런타임 이전에 위치에 상관없이 선언문을 먼저 실행한다. 이렇게 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 호이스팅(Hoisting) 이라고 한다. 호이스팅은 변수 선언 뿐만아니라 var, let, const, function, function*, class 키워드를 사용한 식별자 전부 호이스팅 된다. 하지만, 호이스팅이 된다고 해서 모두 선언 이전에 사용할 수 있는 것은 아니다.","link":"/2021/04/04/javascript-variable/"},{"title":"Add Two Numbers","text":"역순으로 숫자가 저장된 링크드 리스트 l1, l2가 주어질 때 두 숫자의 합의 역순을 링크드 리스트로 반환하는 문제 제약사항 1. 링크드 리스트의 노드 수의 범위는 1 ~ 100 2. 0 &lt;= Node.val &lt;= 9 3. 숫자는 0으로 시작하지 않는다 LeetCode 2. Add Two Numbers Example 1: Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8] Example 2: Input: l1 = [0], l2 = [0]Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]Output: [8,9,9,9,0,0,0,1] Solution/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */const addTwoNumbers = (l1, l2) =&gt; { let carry = 0; let head; let current; while(l1 || l2 || carry) { const val1 = l1 ? l1.val : 0; const val2 = l2 ? l2.val : 0; let sum = val1 + val2 + carry; carry = 0; if(sum &gt;= 10) { carry = Math.floor(sum / 10); sum %= 10; } if(!head) { head = new ListNode(sum); current = head; } else { current.next = new ListNode(sum); current = current.next; } if(l1) l1 = l1.next; if(l2) l2 = l2.next; } return head;}; head부터 tail까지 수의 덧셈을 진행하는 문제로 두 수의 결과가 10 이상이 되면 올림을 해주어야 한다. 먼저 올림 수를 저장할 변수 carry를 선언하고 반환할 head와 현재 노드를 저장할 current를 선언한다. let carry = 0;let head;let current; l1, l2, carray 세 값이 모두 존재하지 않을 때까지 반복하는 while 문을 선언한다. while(l1 || l2 || carry) {} 반복문 내부에서 값이 있으면 값을 선택하고 없으면 0을 선택하여 더한 후 10보다 큰 경우 올림수와 더한 값을 변경한다. const val1 = l1 ? l1.val : 0;const val2 = l2 ? l2.val : 0;let sum = val1 + val2 + carry;carry = 0;// 10보다 큰 경우 10의 배수만큼 올림수에 저장하고// 10으로 나눈 나머지를 sum에 저장한다if(sum &gt;= 10) { carry = Math.floor(sum / 10); sum %= 10;} 만약 head에 값이 없다면 링크드 리스트를 만들어 저장 후 current에 head를 저장한다. head에 값이 있다면 다음 노드에 값을 만들어 저장 후 current에 다음 노드를 저장한다. l1, l2에는 반복이 한 번 끝날 때마다 다음 노드를 저장하여 끝까지 순회할 수 있도록 한다. if(!head) { head = new ListNode(sum); current = head;} else { current.next = new ListNode(sum); current = current.next;}if(l1) l1 = l1.next;if(l2) l2 = l2.next; 마지막으로 head를 반환하면 각 수의 합을 역순으로 저장한 링크드 리스트가 반환된다.","link":"/2021/04/18/leet-code-add-two-numbers/"},{"title":"Remove Nth Node From End of List","text":"연결 리스트의 head가 주어질때 뒤에서 n번째 노드를 제거한 후 head를 리턴 제약사항1. 리스트의 노드의 숫자는 size로 한다.2. 1 &lt;= size &lt;= 303. 0 &lt;= Node.val &lt;= 1004. 1 &lt;= n &lt;= size LeetCode 19. Remove Nth Node From End of List Example 1: Input: head = [1,2,3,4,5], n = 2Output: [1,2,3,5] Example 2: Input: head = [1], n = 1Output: [] Example 3: Input: head = [1,2], n = 1Output: [1] Solution/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @param {number} n * @return {ListNode} */const removeNthFromEnd = (head, n) =&gt; { let prev = head, next = head; // block 1) while(n--) { next = next.next; } // block 2) while(next &amp;&amp; next.next) { prev = prev.next; next = next.next; } // block 3) if(!next) { head = head.next; // block 4) } else { prev.next = prev.next ? prev.next.next : null; } return head;}; Block 1) let prev = head, next = head;while(n--) { next = next.next;} 먼저 제거할 타겟의 이전 노드와 다음 노드를 알아내기 위해 prev, next변수를 선언하고 next를 n번 만큼 움직인다. Block 2) while(next &amp;&amp; next.next) { prev = prev.next; next = next.next;} 그 뒤 next가 끝에 도달할 때 까지 prev와 같이 움직여주면 prev는 타겟의 이전 노드가 된다. 1 - 2 - 3 - 4(target) - 5 인 리스트가 있을 때 먼저 n만큼 next를 움직이면 다음과 같다. 1(prev) - 2 - 3(next) - 4(target) - 5 그리고 next가 끝에 도달할 때 까지 prev를 같이 움직이면 최종적으로 다음과 같다. 1 - 2 - 3(prev) - 4(target) - 5(next) Block 3) if(!next) { head = head.next;} 두 번째 while문은 next의 다음 노드가 없을 때는 실행하지 않기 때문에 위의 블록에 진입했다면 첫 번째 while문에서 이미 next가 null이 된것이다. 이 경우는 head가 지워지는 노드이다. 따라서, head에 head.next를 주입한다. head.next에 아무것도 없다면 자연스럽게 null을 리턴할것이다. Block 4) else { prev.next = prev.next ? prev.next.next : null;} prev는 타겟의 왼쪽 노드로 만약 타겟이 있다면 prev.next에 타겟의 .next를 주입한다. 만약 아무것도 없다면 null을 주입한다. return head; 마지막으로 head를 리턴하면 문제가 해결된다.","link":"/2021/03/29/leet-code-remove-nth-node-from-end-of-list/"},{"title":"Two Sum","text":"정수 배열 nums와 정수 target이 주어질 때 더해서 target이 되는 두 수를 구하는 문제 제약사항 1. 2","link":"/2021/04/05/leet-code-two-sum/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"language","slug":"language","link":"/categories/language/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"javascript","slug":"language/javascript","link":"/categories/language/javascript/"}]}